<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java_Reflect反射详解</title>
      <link href="/2020/01/06/Java-Reflect/"/>
      <url>/2020/01/06/Java-Reflect/</url>
      
        <content type="html"><![CDATA[<p>Java 反射详解！</p><a id="more"></a><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="一、反射的概述"><a href="#一、反射的概述" class="headerlink" title="一、反射的概述"></a>一、反射的概述</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p><p><strong>总结：反射就是Java在运行时才知道要操作的类什么，并且可以在运行时获取类的完整构造（方法、属性、构造函数…），并可以调用所有的方法</strong></p><p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p><p>如图是类的正常加载过程：</p><p>反射的原理就在于class对象，Class对象的由来是：JVM将class文件读入内存时，并为之创建一个Class对象。</p><p><img src="https://img-blog.csdn.net/20170513133210763" alt="类的加载过程"></p><p>其中Class对象在反射中很重要，所以我们先来了解一下Class对象</p><h2 id="二、Class的概述"><a href="#二、Class的概述" class="headerlink" title="二、Class的概述"></a>二、Class的概述</h2><p><img src="https://img-blog.csdn.net/20170513135521667" alt="class类"></p><p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）</p><p>Class 没有公共构造方法。Class 对象是在加载类时由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。</p><p>没有公共的构造方法，方法共有64个太多了。下面用到哪个就详解哪个吧</p><p><img src="https://img-blog.csdn.net/20170513144141409" alt="class类的方法"></p><h2 id="三、反射的使用"><a href="#三、反射的使用" class="headerlink" title="三、反射的使用"></a>三、反射的使用</h2><h3 id="1-获取Class对象的三种方式"><a href="#1-获取Class对象的三种方式" class="headerlink" title="1.获取Class对象的三种方式"></a>1.获取Class对象的三种方式</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p><p>在 Java API 中，获取 Class 类对象有三种方法：</p><p>第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.getName(&quot;com.siweisoft.model.User&quot;);</span><br></pre></td></tr></table></figure><p>第二种，使用类对象的 getClass() 方法；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(();</span><br><span class="line">Class clazz = user.getClass;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20170513145317647" alt="Object的getClass()"></p><p>第三种，使用类的.class属性；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = User.class;</span><br></pre></td></tr></table></figure><p><strong>在运行期间，一个类，只有一个对象</strong></p><h3 id="2-通过反射创建类对象"><a href="#2-通过反射创建类对象" class="headerlink" title="2.通过反射创建类对象"></a>2.通过反射创建类对象</h3><p>第一种：通过 Class 对象的 newInstance() 方法；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Apple apple = (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure><p>第二种：通过 Constructor 对象的 newInstance() 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Constructor constructor = clz.getConstructor();</span><br><span class="line">Apple apple = (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure><p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Constructor constructor = clz.getConstructor(String.class, int.class);</span><br><span class="line">Apple apple = (Apple)constructor.newInstance(&quot;红富士&quot;, 15);</span><br></pre></td></tr></table></figure><h3 id="3-获取构造函数"><a href="#3-获取构造函数" class="headerlink" title="3.获取构造函数"></a>3.获取构造函数</h3><p>Student类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package fanshe;</span><br><span class="line"> </span><br><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">//---------------构造方法-------------------</span><br><span class="line">//（默认的构造方法）</span><br><span class="line">Student(String str)&#123;</span><br><span class="line">System.out.println(&quot;(默认)的构造方法 s = &quot; + str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//无参构造方法</span><br><span class="line">public Student()&#123;</span><br><span class="line">System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有一个参数的构造方法</span><br><span class="line">public Student(char name)&#123;</span><br><span class="line">System.out.println(&quot;姓名：&quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//有多个参数的构造方法</span><br><span class="line">public Student(String name ,int age)&#123;</span><br><span class="line">System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//受保护的构造方法</span><br><span class="line">protected Student(boolean n)&#123;</span><br><span class="line">System.out.println(&quot;受保护的构造方法 n = &quot; + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//私有构造方法</span><br><span class="line">private Student(int age)&#123;</span><br><span class="line">System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共有6个构造方法：</p><p>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package fanshe;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；</span><br><span class="line"> * </span><br><span class="line"> * 1.获取构造方法：</span><br><span class="line"> * 1).批量的方法：</span><br><span class="line"> * public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法</span><br><span class="line">            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line">     </span><br><span class="line"> * 2).获取单个的方法，并调用：</span><br><span class="line"> * public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：</span><br><span class="line"> * public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line"> * </span><br><span class="line"> * 调用构造方法：</span><br><span class="line"> * Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line"> */</span><br><span class="line">public class Constructors &#123;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//1.加载Class对象</span><br><span class="line">Class clazz = Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.获取所有公有构造方法</span><br><span class="line">System.out.println(&quot;**********************所有公有构造方法*********************************&quot;);</span><br><span class="line">Constructor[] conArray = clazz.getConstructors();</span><br><span class="line">for(Constructor c : conArray)&#123;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;);</span><br><span class="line">conArray = clazz.getDeclaredConstructors();</span><br><span class="line">for(Constructor c : conArray)&#123;</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;);</span><br><span class="line">Constructor con = clazz.getConstructor(null);</span><br><span class="line">//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span><br><span class="line">//2&gt;、返回的是描述这个无参构造函数的类对象。</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;con = &quot; + con);</span><br><span class="line">//调用构造方法</span><br><span class="line">Object obj = con.newInstance();</span><br><span class="line">//System.out.println(&quot;obj = &quot; + obj);</span><br><span class="line">//Student stu = (Student)obj;</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;);</span><br><span class="line">con = clazz.getDeclaredConstructor(char.class);</span><br><span class="line">System.out.println(con);</span><br><span class="line">//调用构造方法</span><br><span class="line">con.setAccessible(true);//暴力访问(忽略掉访问修饰符)</span><br><span class="line">obj = con.newInstance(&apos;男&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**********************所有公有构造方法*********************************</span><br><span class="line">public fanshe.Student(java.lang.String,int)</span><br><span class="line">public fanshe.Student(char)</span><br><span class="line">public fanshe.Student()</span><br><span class="line">************所有的构造方法(包括：私有、受保护、默认、公有)***************</span><br><span class="line">private fanshe.Student(int)</span><br><span class="line">protected fanshe.Student(boolean)</span><br><span class="line">public fanshe.Student(java.lang.String,int)</span><br><span class="line">public fanshe.Student(char)</span><br><span class="line">public fanshe.Student()</span><br><span class="line">fanshe.Student(java.lang.String)</span><br><span class="line">*****************获取公有、无参的构造方法*******************************</span><br><span class="line">con = public fanshe.Student()</span><br><span class="line">调用了公有、无参构造方法执行了。。。</span><br><span class="line">******************获取私有构造方法，并调用*******************************</span><br><span class="line">public fanshe.Student(char)</span><br><span class="line">姓名：男</span><br></pre></td></tr></table></figure><p>调用的api：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">批量的方法：</span><br><span class="line">public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法</span><br><span class="line">public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line"></span><br><span class="line">获取单个的方法，并调用：</span><br><span class="line">public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：</span><br><span class="line">public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line"></span><br><span class="line">调用构造方法：</span><br><span class="line">Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line"></span><br><span class="line">newInstance(Object... initargs)是 Constructor类的方法（管理构造函数的类）</span><br><span class="line">使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</span><br><span class="line">它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</span><br></pre></td></tr></table></figure><h3 id="4-获取成员变量并调用"><a href="#4-获取成员变量并调用" class="headerlink" title="4.获取成员变量并调用"></a>4.获取成员变量并调用</h3><p>student类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package fanshe.field;</span><br><span class="line"> </span><br><span class="line">public class Student &#123;</span><br><span class="line">public Student()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//**********字段*************//</span><br><span class="line">public String name;</span><br><span class="line">protected int age;</span><br><span class="line">char sex;</span><br><span class="line">private String phoneNum;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public String toString() &#123;</span><br><span class="line">return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex</span><br><span class="line">+ &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package fanshe.field;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">/*</span><br><span class="line"> * 获取成员变量并调用：</span><br><span class="line"> * </span><br><span class="line"> * 1.批量的</span><br><span class="line"> * 1).Field[] getFields():获取所有的&quot;公有字段&quot;</span><br><span class="line"> * 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</span><br><span class="line"> * 2.获取单个的：</span><br><span class="line"> * 1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span><br><span class="line"> * 2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</span><br><span class="line"> * </span><br><span class="line"> *  设置字段的值：</span><br><span class="line"> * Field --&gt; public void set(Object obj,Object value):</span><br><span class="line"> * 参数说明：</span><br><span class="line"> * 1.obj:要设置的字段所在的对象；</span><br><span class="line"> * 2.value:要为字段设置的值；</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class Fields &#123;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//1.获取Class对象</span><br><span class="line">Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;);</span><br><span class="line">//2.获取字段</span><br><span class="line">System.out.println(&quot;************获取所有公有的字段********************&quot;);</span><br><span class="line">Field[] fieldArray = stuClass.getFields();</span><br><span class="line">for(Field f : fieldArray)&#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;);</span><br><span class="line">fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">for(Field f : fieldArray)&#123;</span><br><span class="line">System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;);</span><br><span class="line">Field f = stuClass.getField(&quot;name&quot;);</span><br><span class="line">System.out.println(f);</span><br><span class="line">//获取一个对象</span><br><span class="line">Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();</span><br><span class="line">//为字段设置值</span><br><span class="line">f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span><br><span class="line">//验证</span><br><span class="line">Student stu = (Student)obj;</span><br><span class="line">System.out.println(&quot;验证姓名：&quot; + stu.name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(&quot;**************获取私有字段****并调用********************************&quot;);</span><br><span class="line">f = stuClass.getDeclaredField(&quot;phoneNum&quot;);</span><br><span class="line">System.out.println(f);</span><br><span class="line">f.setAccessible(true);//暴力反射，解除私有限定</span><br><span class="line">f.set(obj, &quot;18888889999&quot;);</span><br><span class="line">System.out.println(&quot;验证电话：&quot; + stu);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">************获取所有公有的字段********************</span><br><span class="line">public java.lang.String fanshe.field.Student.name</span><br><span class="line">************获取所有的字段(包括私有、受保护、默认的)********************</span><br><span class="line">public java.lang.String fanshe.field.Student.name</span><br><span class="line">protected int fanshe.field.Student.age</span><br><span class="line">char fanshe.field.Student.sex</span><br><span class="line">private java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">*************获取公有字段**并调用***********************************</span><br><span class="line">public java.lang.String fanshe.field.Student.name</span><br><span class="line">验证姓名：刘德华</span><br><span class="line">**************获取私有字段****并调用********************************</span><br><span class="line">private java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">验证电话：Student [name=刘德华, age=0, sex=</span><br></pre></td></tr></table></figure><h3 id="5-获取成员方法并调用"><a href="#5-获取成员方法并调用" class="headerlink" title="5.获取成员方法并调用"></a>5.获取成员方法并调用</h3><p>student类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package fanshe.method;</span><br><span class="line"> </span><br><span class="line">public class Student &#123;</span><br><span class="line">//**************成员方法***************//</span><br><span class="line">public void show1(String s)&#123;</span><br><span class="line">System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s);</span><br><span class="line">&#125;</span><br><span class="line">protected void show2()&#123;</span><br><span class="line">System.out.println(&quot;调用了：受保护的，无参的show2()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void show3()&#123;</span><br><span class="line">System.out.println(&quot;调用了：默认的，无参的show3()&quot;);</span><br><span class="line">&#125;</span><br><span class="line">private String show4(int age)&#123;</span><br><span class="line">System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age);</span><br><span class="line">return &quot;abcd&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package fanshe.method;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 获取成员方法并调用：</span><br><span class="line"> * </span><br><span class="line"> * 1.批量的：</span><br><span class="line"> * public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）</span><br><span class="line"> * public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</span><br><span class="line"> * 2.获取单个的：</span><br><span class="line"> * public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):</span><br><span class="line"> * 参数：</span><br><span class="line"> * name : 方法名；</span><br><span class="line"> * Class ... : 形参的Class类型对象</span><br><span class="line"> * public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</span><br><span class="line"> * </span><br><span class="line"> *  调用方法：</span><br><span class="line"> * Method --&gt; public Object invoke(Object obj,Object... args):</span><br><span class="line"> * 参数说明：</span><br><span class="line"> * obj : 要调用方法的对象；</span><br><span class="line"> * args:调用方式时所传递的实参；</span><br><span class="line">):</span><br><span class="line"> */</span><br><span class="line">public class MethodClass &#123;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">//1.获取Class对象</span><br><span class="line">Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;);</span><br><span class="line">//2.获取所有公有方法</span><br><span class="line">System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);</span><br><span class="line">stuClass.getMethods();</span><br><span class="line">Method[] methodArray = stuClass.getMethods();</span><br><span class="line">for(Method m : methodArray)&#123;</span><br><span class="line">System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;);</span><br><span class="line">methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">for(Method m : methodArray)&#123;</span><br><span class="line">System.out.println(m);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;***************获取公有的show1()方法*******************&quot;);</span><br><span class="line">Method m = stuClass.getMethod(&quot;show1&quot;, String.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line">//实例化一个Student对象</span><br><span class="line">Object obj = stuClass.getConstructor().newInstance();</span><br><span class="line">m.invoke(obj, &quot;刘德华&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;***************获取私有的show4()方法******************&quot;);</span><br><span class="line">m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line">m.setAccessible(true);//解除私有限定</span><br><span class="line">Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span><br><span class="line">System.out.println(&quot;返回值：&quot; + result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">***************获取所有的”公有“方法*******************</span><br><span class="line">public void fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public java.lang.String java.lang.Object.toString()</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">***************获取所有的方法，包括私有的*******************</span><br><span class="line">public void fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">private java.lang.String fanshe.method.Student.show4(int)</span><br><span class="line">protected void fanshe.method.Student.show2()</span><br><span class="line">void fanshe.method.Student.show3()</span><br><span class="line">***************获取公有的show1()方法*******************</span><br><span class="line">public void fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">调用了：公有的，String参数的show1(): s = 刘德华</span><br><span class="line">***************获取私有的show4()方法******************</span><br><span class="line">private java.lang.String fanshe.method.Student.show4(int)</span><br><span class="line">调用了，私有的，并且有返回值的，int参数的show4(): age = 20</span><br><span class="line">返回值：abcd</span><br></pre></td></tr></table></figure><h3 id="6-反射方法的其它使用之—通过反射越过泛型检查"><a href="#6-反射方法的其它使用之—通过反射越过泛型检查" class="headerlink" title="6.反射方法的其它使用之—通过反射越过泛型检查"></a>6.反射方法的其它使用之—通过反射越过泛型检查</h3><p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的</p><p>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 通过反射越过泛型检查</span><br><span class="line"> * </span><br><span class="line"> * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</span><br><span class="line"> */</span><br><span class="line">public class Demo &#123;</span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();</span><br><span class="line">strList.add(&quot;aaa&quot;);</span><br><span class="line">strList.add(&quot;bbb&quot;);</span><br><span class="line"></span><br><span class="line">//strList.add(100);</span><br><span class="line">//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span><br><span class="line">Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象</span><br><span class="line">//获取add()方法</span><br><span class="line">Method m = listClass.getMethod(&quot;add&quot;, Object.class);</span><br><span class="line">//调用add()方法</span><br><span class="line">m.invoke(strList, 100);</span><br><span class="line"></span><br><span class="line">//遍历集合</span><br><span class="line">for(Object obj : strList)&#123;</span><br><span class="line">System.out.println(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射的源码解析"><a href="#反射的源码解析" class="headerlink" title="反射的源码解析"></a>反射的源码解析</h2><p>当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException </span><br><span class="line">...</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:497)</span><br></pre></td></tr></table></figure><p>可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = clz.getMethod(&quot;setPrice&quot;, int.class); </span><br><span class="line">method.invoke(object, 4);   //就是这里的invoke方法</span><br></pre></td></tr></table></figure><p>例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.chenshuyi.Apple&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。</p><p>从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。</p><p>下面我们来看看 JDK 的 invoke 方法到底做了些什么。</p><p>进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000148605-1162314142.png" alt="MethodAccessor类的invoke"></p><p>那么 MethodAccessor 又是什么呢？</p><p>其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：</p><p>sun.reflect.DelegatingMethodAccessorImpl<br>sun.reflect.MethodAccessorImpl<br>sun.reflect.NativeMethodAccessorImpl<br>而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000158770-762759003.png" alt="acquireMethodAccessor()"></p><p>从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000210324-586245969.png" alt="image"></p><p>在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。</p><p>这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000220034-1956129765.png" alt="image"></p><p>所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000232803-804506620.png" alt="image"></p><p>进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000240115-804972243.png" alt="image"></p><p>而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。</p><p>到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。</p><blockquote><p>“Inflation” mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.</p><p>Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。</p><p>To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.</p><p>为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。</p></blockquote><p>就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。</p><p>Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。</p><p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p><p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000247330-1279629878.png" alt="image"></p><p>讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。</p><p>参考文章：</p><p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java基础之—反射（非常重要）</a><br><a href="http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html" target="_blank" rel="noopener">大白话说Java反射：入门、使用、原理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java Reflect 反射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习总结</title>
      <link href="/2020/01/05/gitSummary/"/>
      <url>/2020/01/05/gitSummary/</url>
      
        <content type="html"><![CDATA[<p>Git 学习总结</p><a id="more"></a><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>Git在工作中经常用到，但是指令太多，网上的说法又不太通俗。总会让想要学习的同学抓不到重点，或者望而却步。这篇文章的目的就是希望读后能够按照原理，系统地记忆一些常用/关键的命令。也算是我这个刚入互联网的小白对社会的一些小小福报～其中若有不当之处，欢迎大佬指出。</p></blockquote><p><img src="http://img1.imgtn.bdimg.com/it/u=2551559286,1842849149&fm=26&gp=0.jpg" alt></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Git是一个分布式版本控制系统，为了快速高效地处理小到大型项目的所有内容。通过对信息的压缩和摘要，使得所占空间非常小，但能够支持项目版本迅速迭代的开发工具。</p><h2 id="一、Git的分区"><a href="#一、Git的分区" class="headerlink" title="一、Git的分区"></a>一、Git的分区</h2><p>本章主要从基础入手，先介绍git的分区。</p><h3 id="1-1-三大分区"><a href="#1-1-三大分区" class="headerlink" title="1.1 三大分区"></a>1.1 三大分区</h3><ul><li>工作区，也叫Working Directory</li><li>暂存区，也叫stage，index</li><li>版本库，也叫本地仓库，commit History</li></ul><p>当我们把代码从git hub clone下来或者说初始化git项目后，便有了这三个分区的概念。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi04Mjg4YzhjMDkwNTZjZTMwOGYyMGY3ODFmNDQ3ZmQ2Y19oZC5qcGc?x-oss-process=image/format,png" alt="文件在Git不同分区中的表现"></p><p><strong>工作区</strong><br>工作区应该不陌生，就是我们能看见，直接编辑的区域。对于一些新增的文件，如果没有被add到暂存区，就会以红色的形式放置在工作区。</p><p><strong>暂存区</strong><br>数据暂时存放的区域，对于add git版本控制的文件，就算是进入暂存区啦。可以理解为数据进入本地代码仓库之前存放的区域。由于还没对本地仓库生效，所以是数据暂时存放的区域。</p><p>对暂存区的文件修改后，会以蓝色的形式显示。如果第一次创建并add到暂存区的文件，由于远程仓库没有同步，所以会显示绿色。<br><code>注：存放在 &quot;.git目录下&quot; 下的index文件（.git/index）中。</code></p><p><strong>版本库</strong><br>在暂存区commit的代码会被放入版本库中。可以理解为一个本地的代码仓库，push的时候，才会把版本库的数据全都发送到远程仓库中。<br><code>注：存放在工作区中“.git”目录下。</code><br><img src="https://www.runoob.com/wp-content/uploads/2015/02/1352126739_7909.jpg" alt></p><p>扩展阅读：<br><a href="https://juejin.im/post/5b6c4eeff265da0f4d0da3fa" target="_blank" rel="noopener">https://juejin.im/post/…</a><br><a href="https://www.runoob.com/git/git-workspace-index-repo.html" target="_blank" rel="noopener">https://www.runoob.com/git/…</a></p><h3 id="1-1-涉及指令"><a href="#1-1-涉及指令" class="headerlink" title="1.1 涉及指令"></a>1.1 涉及指令</h3><h4 id="1-1-2-分区转换指令"><a href="#1-1-2-分区转换指令" class="headerlink" title="1.1.2 分区转换指令"></a>1.1.2 分区转换指令</h4><p><strong>git add</strong><br>数据从工作区转移至暂存区</p><p><strong>git commit</strong><br>数据从暂存区转移至版本库，也就是本地仓库</p><p><strong>git push</strong><br>数据从版本库中发送到远程仓库</p><p>指令太多？一张图就能记下～<br><img src="https://pic4.zhimg.com/80/v2-8e73605a803bd29ceacd86923e08f5f0_hd.jpg" alt></p><h4 id="1-1-2-分区对比指令"><a href="#1-1-2-分区对比指令" class="headerlink" title="1.1.2 分区对比指令"></a>1.1.2 分区对比指令</h4><p><strong>git diff</strong><br>工作区与暂存区对比</p><p><strong>git diff head</strong><br>工作区与版本库对比</p><p><strong>git diff -cached</strong><br>暂存区与版本库对比</p><p>指令太多？一张图就能记下～<br><img src="https://pic1.zhimg.com/80/v2-e95ac3baeb28734107f8bec468525661_hd.jpg" alt></p><h2 id="二、Git的原理"><a href="#二、Git的原理" class="headerlink" title="二、Git的原理"></a>二、Git的原理</h2><p>操作Git代码库前，一定要了解Git是怎么记录每次提交的代码变化的？换句话说，每一次commit在保证开发效率的前提下，都提交了什么？</p><h3 id="2-1-git如何存储文件-目录信息"><a href="#2-1-git如何存储文件-目录信息" class="headerlink" title="2.1 git如何存储文件/目录信息"></a>2.1 git如何存储文件/目录信息</h3><p>首先我们使用<code>git init</code>，初始化一个新的git项目。这个目录会在项目的根目录下创建.git的隐藏目录，相信大家都不陌生。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:wuya eleme$ git init</span><br><span class="line">已初始化空的 Git 仓库于 /Users/eleme/wuya/.git/</span><br></pre></td></tr></table></figure><p>然后查看一下.git的目录树</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:wuya eleme$ tree -a</span><br><span class="line">.</span><br><span class="line">└── .git</span><br><span class="line">    ├── HEAD</span><br><span class="line">    ├── config</span><br><span class="line">    ├── description</span><br><span class="line">    ├── hooks</span><br><span class="line">    │   ├── applypatch-msg.sample</span><br><span class="line">    │   ├── commit-msg.sample</span><br><span class="line">    │   ├── fsmonitor-watchman.sample</span><br><span class="line">    │   ├── post-update.sample</span><br><span class="line">    │   ├── pre-applypatch.sample</span><br><span class="line">    │   ├── pre-commit.sample</span><br><span class="line">    │   ├── pre-push.sample</span><br><span class="line">    │   ├── pre-rebase.sample</span><br><span class="line">    │   ├── pre-receive.sample</span><br><span class="line">    │   ├── prepare-commit-msg.sample</span><br><span class="line">    │   └── update.sample</span><br><span class="line">    ├── info</span><br><span class="line">    │   └── exclude</span><br><span class="line">    ├── objects</span><br><span class="line">    │   ├── info</span><br><span class="line">    │   └── pack</span><br><span class="line">    └── refs</span><br><span class="line">        ├── heads</span><br><span class="line">        └── tags</span><br><span class="line"></span><br><span class="line">9 directories, 15 files</span><br></pre></td></tr></table></figure><p>我们会发现，有一个叫Objects的目录。这个目录就是存储文件变化的核心。我们往工作区中存入一个测试文件a.md和一个test文件夹并查看objects发生的变化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:wuya eleme$ <span class="built_in">echo</span> <span class="string">'test1'</span> &gt; a.md</span><br><span class="line">MacBook-Pro:wuya eleme$ mkdir <span class="built_in">test</span></span><br><span class="line">MacBook-Pro:wuya eleme$ <span class="built_in">echo</span> <span class="string">'test2'</span> &gt; <span class="built_in">test</span>/b.md</span><br><span class="line">MacBook-Pro:wuya eleme$ git add a.md <span class="built_in">test</span></span><br><span class="line">MacBook-Pro:wuya eleme$ tree -a .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">├── 18</span><br><span class="line">│   └── 0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">├── 9d</span><br><span class="line">│   └── aeafb9864cf43055ae93beb0afd6c7d144bfa4</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br><span class="line"></span><br><span class="line">4 directories, 2 files</span><br></pre></td></tr></table></figure><p>注意，文件夹放入到暂存区后，并不会马上在objects中显示，commit后才会。此时多了两个文件，其实就是修改过的两个文件以及修改内容。<br>Objects下存放的<strong>文件名</strong>就是根据SHA1算法哈希的“指纹”，为了能够在本仓库中和其他文件区分出来。<strong>文件内容</strong>就是Git将信息压缩后形成的二进制文件。通过git cat-file [-t] [-p]，可以看到Object的类型与文件的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:wuya eleme$ git cat-file -t 9dae</span><br><span class="line">blob</span><br><span class="line">MacBook-Pro:wuya eleme$ git cat-file -p 9dae</span><br><span class="line">test1</span><br></pre></td></tr></table></figure><p>通过<figure class="highlight plain"><figcaption><span>hash-object a.md```能够显示该文件在本仓库生成的hash值，与之前的目录树显示是对应的。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">MacBook-Pro:wuya eleme$ git hash-object a.md</span><br><span class="line">9daeafb9864cf43055ae93beb0afd6c7d144bfa4</span><br></pre></td></tr></table></figure></p><h3 id="2-2-git-Object的类型"><a href="#2-2-git-Object的类型" class="headerlink" title="2.2 git Object的类型"></a>2.2 git Object的类型</h3><p>git Object有三种类型：</p><ul><li>Blob</li><li>Tree</li><li>Commit</li></ul><p>简单来说，文件都被存储为Blob类型，文件夹则为Tree类型，每次提交的节点被存储为Commit类型数据。因此，Git会以这三种类型来存储我们的文件。简单看下目录存储的映射关系：<br><img src="https://pic2.zhimg.com/80/v2-b1da1f9d9ba4212b80a98000e80f75d4_hd.jpg" alt><br>初步猜想，如果把这些文件都commit到代码库，objects目录应该会有4个目录。即2个blob，1个tree，1个commit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:wuya eleme$ git commit -a -m <span class="string">"加入到代码库中，观察objects目录变化"</span></span><br><span class="line">[master（根提交） a16b538] 加入到代码库中，观察objects目录变化</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 a.md</span><br><span class="line"> create mode 100644 <span class="built_in">test</span>/b.md</span><br><span class="line">MacBook-Pro:wuya eleme$ tree -a .git/objects</span><br><span class="line">.git/objects</span><br><span class="line">├── 18</span><br><span class="line">│   └── 0cf8328022becee9aaa2577a8f84ea2b9f3827</span><br><span class="line">├── 21</span><br><span class="line">│   └── d0758079bdf2c8f7514687174454c804eb0c74</span><br><span class="line">├── 9d</span><br><span class="line">│   └── aeafb9864cf43055ae93beb0afd6c7d144bfa4</span><br><span class="line">├── a1</span><br><span class="line">│   └── 6b5382a9b646a7df8d21301391f29b2f7bfb65</span><br><span class="line">├── a7</span><br><span class="line">│   └── 6c93bb75184ef4b34c88a301c2351ae2219407</span><br><span class="line">├── info</span><br><span class="line">└── pack</span><br><span class="line"></span><br><span class="line">7 directories, 5 files</span><br></pre></td></tr></table></figure><p>然而事实却是….5个目录！多出的那一个是什么？一个一个输出看看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:wuya eleme$ git cat-file -p 9dae</span><br><span class="line">test1</span><br><span class="line">MacBook-Pro:wuya eleme$ git cat-file -p 180c</span><br><span class="line">test2</span><br><span class="line">MacBook-Pro:wuya eleme$ git cat-file -p 21d0</span><br><span class="line">100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827b.md</span><br><span class="line">MacBook-Pro:wuya eleme$ git cat-file -p a16b</span><br><span class="line">tree a76c93bb75184ef4b34c88a301c2351ae2219407</span><br><span class="line">author eleme &lt;xxxx@qq.com&gt; 1576979515 +0800</span><br><span class="line">committer eleme &lt;xxxx@qq.com&gt; 1576979515 +0800</span><br><span class="line"></span><br><span class="line">加入到代码库中，观察objects目录变化</span><br><span class="line">MacBook-Pro:wuya eleme$ git cat-file -p a76c</span><br><span class="line">100644 blob 9daeafb9864cf43055ae93beb0afd6c7d144bfa4a.md</span><br><span class="line">040000 tree 21d0758079bdf2c8f7514687174454c804eb0c74<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>整理一下各自类型：</p><ul><li>9dae-blob</li><li>180c-blob</li><li>21d0-tree</li><li>a16b-commit</li><li>a76c-tree</li></ul><p>仔细一想其实也就通了，两个tree是git根目录和test目录。<br>可以得出这样一个结论：每一次commit，都会生成与之对应的commit hash值。查看历史commit也很容易得出这个结论：<br><img src="https://pic2.zhimg.com/80/v2-bc51d779f84b5bb0c0078d4ceb28efc9_hd.jpg" alt><br>扩展阅读：<br><a href="https://mp.weixin.qq.com/s/d4WA02Y22gdWRbmmwfPEHQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/…</a></p><h2 id="三、Git的分支"><a href="#三、Git的分支" class="headerlink" title="三、Git的分支"></a>三、Git的分支</h2><h3 id="3-1-初探Git分支"><a href="#3-1-初探Git分支" class="headerlink" title="3.1 初探Git分支"></a>3.1 初探Git分支</h3><p>在学习Git分支之前，还是从git的目录树入手。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:wuya eleme$ tree -a .git</span><br><span class="line">.git</span><br><span class="line">├── ......</span><br><span class="line">├── HEAD</span><br><span class="line">└── refs</span><br><span class="line">    ├── heads</span><br><span class="line">    │   └── master</span><br><span class="line">    ├── remotes</span><br><span class="line">    │   └── origin</span><br><span class="line">    │       └── HEAD</span><br><span class="line">    └── tags</span><br></pre></td></tr></table></figure><p>不难看出refs目录就是用来记录当前对分支的引用信息，包括本地分支，远程分支，标签。</p><p>heads记录的是本地所有分支，remotes和HEAD一样，指向对应的某个远程分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:wuya eleme$ cat .git/refs/heads/master</span><br><span class="line">a16b5382a9b646a7df8d21301391f29b2f7bfb65</span><br></pre></td></tr></table></figure><p>细心些就会发现，这个<strong>hash值就是commit节点的hash值</strong>。</p><p>而<strong>HEAD</strong>就是存储当前在哪个本地分支。查看其内容，可以发现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:.git eleme$ cat HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure><p>也就意味着，我们在本地的master上。除此之外，还可以通过<code>git branch</code>来创建其他分支。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:.git eleme$ git branch feature/dev</span><br><span class="line">MacBook-Pro:.git eleme$ git branch feature/wuya</span><br></pre></td></tr></table></figure><p>切换到其他分支并查看分支信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">elemedeMacBook-Pro:wuya eleme$ git checkout feature/dev</span><br><span class="line">切换到分支 <span class="string">'feature/dev'</span></span><br><span class="line">elemedeMacBook-Pro:wuya eleme$ git branch -vv</span><br><span class="line">* feature/dev  a16b538 加入到代码库中，观察objects目录变化</span><br><span class="line">  feature/wuya a16b538 加入到代码库中，观察objects目录变化</span><br><span class="line">  master       a16b538 加入到代码库中，观察objects目录变化</span><br></pre></td></tr></table></figure><p>因此可知分支当前的指针指向最近一次commit的节点。通过<strong>谁创建的分支，就沿用谁的指针。</strong>注：未被放入代码库的文件会在分支切换时被抛弃，造成严重后果。</p><h3 id="3-2-合并Git分支"><a href="#3-2-合并Git分支" class="headerlink" title="3.2 合并Git分支"></a>3.2 合并Git分支</h3><p>分支的合并有两种方式，merge和rebase。</p><p>相同点：都是从一个分支获取并合并到当前分支。</p><p><strong>merge</strong>：自动创建一个新的commit，如果遇到冲突，仅需要修改后重新commit。<br><img src="https://pic2.zhimg.com/80/v2-009bf3dd1eb907bb84aa4970d4b7afd4_hd.jpg" alt><br>每次都记录了真实详细的commit，但是在commit频繁的时候，会看到分支比较乱。比如这样，全是merge产生的节点：<br><img src="https://pic1.zhimg.com/80/v2-221ac1d2610b17994333c00e8943c2a5_hd.jpg" alt><br>rebase：找公共的节点，直接合并之前commit历史。<br><img src="https://pic2.zhimg.com/80/v2-d7029972815230a42ac73c108d19f67d_hd.jpg" alt></p><p>这样能得到简洁的分支发展历史，去掉了merge commit。但是如果合并时出现了问题，没有留下痕迹，不好定位。</p><ul><li>git rebase –abort：遇到冲突时放弃合并，回到rebase操作之前的状态。</li><li>git rebase –continue：合并冲突，结合”git add 文件”命令一起，一步一步地解决冲突。</li><li>git rebase –skip：将引起冲突的commits丢弃掉。<h4 id="小例子"><a href="#小例子" class="headerlink" title="小例子"></a>小例子</h4>这里引用一个网上归纳的git rebase工作流：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git rebase </span><br><span class="line">while(存在冲突) &#123;</span><br><span class="line">    //找到当前冲突文件，编辑解决冲突</span><br><span class="line">    git status</span><br><span class="line">    git add -u</span><br><span class="line">    git rebase --continue</span><br><span class="line">    if( git rebase --abort )</span><br><span class="line">        break; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注：最好不要在公共分支上使用rebase，如果前后基本上不会有别人改动你的分支，那么推荐rebase。</p><p>扩展阅读：<br><a href="https://blog.csdn.net/chenansic/article/details/44122107" target="_blank" rel="noopener">https://blog.csdn.net/…</a></p><h3 id="3-3-分支的冲突"><a href="#3-3-分支的冲突" class="headerlink" title="3.3 分支的冲突"></a>3.3 分支的冲突</h3><h4 id="冲突的产生"><a href="#冲突的产生" class="headerlink" title="冲突的产生"></a>冲突的产生</h4><p>冲突是从合并的时候产生的。git分支的合并，其实就是<strong>tree和tree的合并</strong>。我们在feature/dev上执行<code>git merge master</code>时。<strong>git会先找到这两个分支是从哪个指针创建出来的，称之为“merge base”。然后检查这两次的tree是否一致，如果不一致说明一定有文件发生了修改</strong>。接下来，对于某一个文件来说，分几种情况：<br><img src="https://pic4.zhimg.com/80/v2-bf2e0c9a245eaf25bf06cbad6ba086bc_hd.jpg" alt></p><ol><li>文件在节点6，节点3，merge base中的hash值都相同。说明没有被修改过。不会有冲突。</li><li>文件在节点6和merge base或者节点3和merge base的hash值相同时，此时直接更新文件的变化。</li><li>文件在节点6，merge request，master上的hash值都不同，冲突就产生了。<br>此时就需要开发人员商定，解决冲突。</li></ol><h2 id="四、版本的回滚"><a href="#四、版本的回滚" class="headerlink" title="四、版本的回滚"></a>四、版本的回滚</h2><p>如果想要版本回退，就离不开reset和revert。</p><h3 id="4-1-revert"><a href="#4-1-revert" class="headerlink" title="4.1 revert"></a>4.1 revert</h3><p>这个就一目了然了，执行<code>git revert</code>后，将回退到上一个commit的版本。</p><h3 id="4-2-reset"><a href="#4-2-reset" class="headerlink" title="4.2 reset"></a>4.2 reset</h3><blockquote><p>前段时间，线上出了好多空指针的bug，当我查看日志定位到某一代码行时，发现该行定位不到对应的方法中。这时候就<strong>必须切换到线上的代码版本</strong>进行排查了。</p></blockquote><p><img src="https://pic4.zhimg.com/80/v2-c05d50580dfcd5fa3f013131f4fdf26e_hd.jpg" alt></p><p>git reset分为三种模式：</p><ul><li>soft</li><li>mixed</li><li>hard</li></ul><p>由于每一次的commit都会产生与之对应的hash值，所以借助这个进行重置就轻松多了。</p><p><strong>git reset –hard commit的hash值</strong><br>会重置暂存区和工作区，完全重置为指定的commit节点。当前分支没有commit的代码<strong>必然会被清除</strong>。</p><p><strong>git reset –soft commit的hash值</strong><br>会保留工作目录，并把指定的commit节点与当前分支的差异<strong>都存入暂存区</strong>。也就是说，没有被commit的代码也能够保留下来。</p><p><strong>git reset commit的hash值</strong><br>不带参数，也就是mixed模式。将会保留工作目录，并且把工作区，暂存区以及与reset的差异<strong>都放到工作区，然后清空暂存区</strong>。因此执行后，只要有所差异，文件都会变成红色，变得难以区分。</p><p>一般情况下，我们使用soft模式，既能保留暂存区，又能reset到某个分支。</p><h2 id="五、代码暂存"><a href="#五、代码暂存" class="headerlink" title="五、代码暂存"></a>五、代码暂存</h2><p>当我们在当前分支工作时，不得已需要切换到其他分支处理事情而不想commit时（如果commit多了，会污染log），可以使用git stash 将那些数据都暂存到Git提供的栈中。用法很简单～</p><p><strong>git stash</strong><br>暂存修改过的代码，保存在<strong>Git栈</strong>中，然后将工作区还原成上一次commit的内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:young eleme$ git stash</span><br><span class="line">保存工作目录和索引状态 WIP on wuya: 82371a5 上一次commit写的message</span><br></pre></td></tr></table></figure><p><strong>git stash list</strong><br>显示之前压栈的所有记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:young eleme$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on aaa: 82371a5 上一次commit写的message</span><br></pre></td></tr></table></figure><p><strong>git stash clear</strong><br>清空Git栈。</p><p><em>git stash apply_</em><br>从Git栈中读取上一次暂存的那些代码，恢复工作区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MacBook-Pro:young eleme$ git stash apply</span><br><span class="line">位于分支 wuya</span><br><span class="line">您的分支与上游分支 &apos;origin/wuya&apos; 一致。</span><br><span class="line"></span><br><span class="line">尚未暂存以备提交的变更：</span><br><span class="line">  （使用 &quot;git add &lt;文件&gt;...&quot; 更新要提交的内容）</span><br><span class="line">  （使用 &quot;git checkout -- &lt;文件&gt;...&quot; 丢弃工作区的改动）</span><br><span class="line"></span><br><span class="line">        修改：     src/main/java/com/young/test/test1.java</span><br><span class="line"></span><br><span class="line">修改尚未加入提交（使用 &quot;git add&quot; 和/或 &quot;git commit -a&quot;）</span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望大家的Git越用越6，如有疑问，欢迎评论。<br>然后…卑微地求一波赞🥺</p><p>参考文章：<br><a href="https://juejin.im/post/5b6c4eeff265da0f4d0da3fa" target="_blank" rel="noopener">https://juejin.im/post/…</a><br><a href="https://www.runoob.com/git/git-workspace-index-repo.html" target="_blank" rel="noopener">https://www.runoob.com/…</a><br><a href="https://mp.weixin.qq.com/s/d4WA02Y22gdWRbmmwfPEHQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/…</a><br><a href="https://blog.csdn.net/chenansic/article/details/44122107" target="_blank" rel="noopener">https://blog.csdn.net/chenansic/…</a><br><a href="https://zhuanlan.zhihu.com/p/96631135" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/…</a></p><p>原文链接：<a href="https://zhuanlan.zhihu.com/p/98679880" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/98679880</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【SpringBoot】的自定义拦截器@Autowired 注入失败解决方案</title>
      <link href="/2020/01/04/InterceptorAutowiredError/"/>
      <url>/2020/01/04/InterceptorAutowiredError/</url>
      
        <content type="html"><![CDATA[<p>拦截器@Autowired注入失败解决方案</p><a id="more"></a><h1 id="自定义Interceptor拦截器-Autowired-注入失败"><a href="#自定义Interceptor拦截器-Autowired-注入失败" class="headerlink" title="自定义Interceptor拦截器@Autowired 注入失败"></a>自定义Interceptor拦截器@Autowired 注入失败</h1><h4 id="异常：自己定义的拦截器在注入-Autowired-时不成功，空指针异常"><a href="#异常：自己定义的拦截器在注入-Autowired-时不成功，空指针异常" class="headerlink" title="异常：自己定义的拦截器在注入@Autowired 时不成功，空指针异常"></a>异常：自己定义的拦截器在注入@Autowired 时不成功，空指针异常</h4><p>自动注入</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2RsMi5pdGV5ZS5jb20vdXBsb2FkL2F0dGFjaG1lbnQvMDEyOC8zMzA3L2YxMGI1ZTY1LTMxMWMtMzY2OS1hMDBkLWYzOWQxYWE3YzFjYy5wbmc" alt="自动注入"></p><p>异常信息</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2RsMi5pdGV5ZS5jb20vdXBsb2FkL2F0dGFjaG1lbnQvMDEyOC8zMzExL2M1ZDFkMDUxLTgxZTMtM2M1MS1hNzYwLTg1M2Q1NDUxODIxNi5wbmc" alt="异常信息"></p><h4 id="原因：造成null的原因是因为拦截器加载是在SpringContext创建之前完成的，所以在拦截器中注入实体自然就为null。"><a href="#原因：造成null的原因是因为拦截器加载是在SpringContext创建之前完成的，所以在拦截器中注入实体自然就为null。" class="headerlink" title="原因：造成null的原因是因为拦截器加载是在SpringContext创建之前完成的，所以在拦截器中注入实体自然就为null。"></a>原因：造成null的原因是因为拦截器加载是在SpringContext创建之前完成的，所以在拦截器中注入实体自然就为null。</h4><h4 id="解决方案：需要在配置类中使用-Bean注解提前去加载。"><a href="#解决方案：需要在配置类中使用-Bean注解提前去加载。" class="headerlink" title="解决方案：需要在配置类中使用@Bean注解提前去加载。"></a>解决方案：需要在配置类中使用@Bean注解提前去加载。</h4><p>如下图：<br><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2RsMi5pdGV5ZS5jb20vdXBsb2FkL2F0dGFjaG1lbnQvMDEyOC8zMzA5LzBhMmMyOGU1LTg2MjUtM2UxYS04NjllLTgwNzlkODhkZjhhMS5wbmc" alt="提前加载"></p><p><strong>ps：同时在配置拦截器时候，添加拦截器不能使用new AppInterceptor()，而是应该使用@Bean注册的方法，进行方法调用添加到拦截器配置里</strong></p><p><img src="https://img-blog.csdnimg.cn/20190802150718692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbnlhbmdiZXN0,size_16,color_FFFFFF,t_70" alt></p><p>问题解决！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Autowired Interceptor SpringBoot 拦截器 自动注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础知识总结</title>
      <link href="/2019/11/08/linux/"/>
      <url>/2019/11/08/linux/</url>
      
        <content type="html"><![CDATA[<p>Linux基础知识总结</p><a id="more"></a><h1 id="Linux-概述"><a href="#Linux-概述" class="headerlink" title="Linux 概述"></a>Linux 概述</h1><p>Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。</p><p>Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution</p><p>目前市面上较知名的发行版有：<strong>Ubuntu</strong>、<strong>Apline</strong> 、RedHat、<strong>CentOS</strong>、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p><h1 id="Linux-与-Windows比较"><a href="#Linux-与-Windows比较" class="headerlink" title="Linux 与 Windows比较"></a>Linux 与 Windows比较</h1><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下：</p><table><thead><tr><th>比较</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>界面</td><td>界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td><td>图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td>驱动程序</td><td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td><td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在 Windows 下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td></tr><tr><td>使用</td><td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td><td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td></tr><tr><td>学习</td><td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td><td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td></tr><tr><td>软件</td><td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td><td>大部分软件都可以自由获取，同样功能的软件选择较少。</td></tr></tbody></table><h1 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/11387217-322c432a9d46f820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)</td></tr><tr><td>boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>dev</td><td>用于存放设备文件</td></tr><tr><td>etc</td><td>存放系统配置文件</td></tr><tr><td>home</td><td>存放所有用户文件的根目录</td></tr><tr><td>lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr><td>mnt</td><td>系统管理员安装临时文件系统的安装点</td></tr><tr><td>opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>proc</td><td>虚拟文件系统，存放当前内存的映射</td></tr><tr><td>root</td><td>超级用户目录</td></tr><tr><td>sbin</td><td>存放二进制可执行文件，只有root才能访问</td></tr><tr><td>tmp</td><td>用于存放各种临时文件</td></tr><tr><td>usr</td><td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td></tr><tr><td>var</td><td>用于存放运行时需要改变数据的文件</td></tr></tbody></table><h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><table><thead><tr><th>命令</th><th>说明</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>ls</td><td>显示文件和目录列表</td><td>ls [-alrtAFR] [name…]</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-l</td><td>列出文件的详细信息</td></tr><tr><td></td><td></td><td></td><td>-a</td><td>列出当前目录所有文件，包含隐藏文件</td></tr><tr><td>mkdir</td><td>创建目录</td><td>mkdir [-p] dirName</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-p</td><td>父目录不存在情况下先生成父目录</td></tr><tr><td>cd</td><td>切换目录</td><td>cd [dirName]</td><td></td><td></td></tr><tr><td>touch</td><td>生成一个空文件</td><td></td><td></td><td></td></tr><tr><td>echo</td><td>生成一个带内容文件</td><td>echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td><td></td><td></td></tr><tr><td>cat</td><td>显示文本文件内容</td><td>cat [-AbeEnstTuv] [–help] [–version] fileName</td><td></td><td></td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp [options] source dest</td><td></td><td></td></tr><tr><td>rm</td><td>删除文件</td><td>rm [options] name…</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-f</td><td>强制删除文件或目录</td></tr><tr><td></td><td></td><td></td><td>-r</td><td>同时删除该目录下的所有文件</td></tr><tr><td>mv</td><td>移动文件或目录</td><td>mv [options] source dest</td><td></td><td></td></tr><tr><td>find</td><td>在文件系统中查找指定的文件</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-name</td><td>文件名</td></tr><tr><td>grep</td><td>在指定的文本文件中查找指定的字符串</td><td></td><td></td><td></td></tr><tr><td>tree</td><td>用于以树状图列出目录的内容</td><td></td><td></td><td></td></tr><tr><td>pwd</td><td>显示当前工作目录</td><td></td><td></td><td></td></tr><tr><td>ln</td><td>建立软链接</td><td></td><td></td><td></td></tr><tr><td>more</td><td>分页显示文本文件内容</td><td></td><td></td><td></td></tr><tr><td>head</td><td>显示文件开头内容</td><td></td><td></td><td></td></tr><tr><td>tail</td><td>显示文件结尾内容</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-f</td><td>跟踪输出</td></tr></tbody></table><h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>stat</td><td>显示指定文件的相关信息,比ls命令显示内容更多</td></tr><tr><td>who</td><td>显示在线登录用户</td></tr><tr><td>hostname</td><td>显示主机名称</td></tr><tr><td>uname</td><td>显示系统信息</td></tr><tr><td>top</td><td>显示当前系统中耗费资源最多的进程</td></tr><tr><td>ps</td><td>显示瞬间的进程状态</td></tr><tr><td>du</td><td>显示指定的文件（目录）已使用的磁盘空间的总量</td></tr><tr><td>df</td><td>显示文件系统磁盘空间的使用情况</td></tr><tr><td>free</td><td>显示当前内存和交换空间的使用情况</td></tr><tr><td>ifconfig</td><td>显示网络接口信息</td></tr><tr><td>ping</td><td>测试网络的连通性</td></tr><tr><td>netstat</td><td>显示网络状态信息</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>kill</td><td>杀死一个进程</td></tr></tbody></table><h2 id="文件压缩命令"><a href="#文件压缩命令" class="headerlink" title="文件压缩命令"></a>文件压缩命令</h2><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>tar</td><td>tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</td><td></td><td></td></tr><tr><td></td><td></td><td>-c</td><td>建立一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-x</td><td>解开一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-z</td><td>是否需要用 gzip 压缩</td></tr><tr><td></td><td></td><td>-j</td><td>是否需要用 bzip2 压缩</td></tr><tr><td></td><td></td><td>-v</td><td>压缩的过程中显示文件</td></tr><tr><td></td><td></td><td>-f</td><td>使用档名，在 f 之后要立即接档名</td></tr><tr><td></td><td></td><td>-tf</td><td>查看归档文件里面的文件</td></tr></tbody></table><h2 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h2><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><p>编辑模式：等待编辑命令输入<br>插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息<br>命令模式：在编辑模式下，输入 : 进行命令模式</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><code>:q</code> 直接退出vi<br><code>:wq</code> 保存后退出vi ，并可以新建文件<br><code>:q!</code> 强制退出<br><code>:w file</code> 将当前内容保存成某个文件<br><code>:set number</code> 在编辑文件显示行号<br><code>:set nonumber</code> 在编辑文件不显示行号</p><h1 id="Linux文件权限管理"><a href="#Linux文件权限管理" class="headerlink" title="Linux文件权限管理"></a>Linux文件权限管理</h1><h2 id="查看文件和目录的权限"><a href="#查看文件和目录的权限" class="headerlink" title="查看文件和目录的权限"></a>查看文件和目录的权限</h2><p><code>ls –al</code>使用 ls 不带参数只显示文件名称，通过<code>ls –al</code> 可以显示文件或者目录的权限信息。<br><code>ls -l 文件名</code> 显示信息包括：文件类型 (<code>d</code>目录，<code>-</code> 普通文件，<code>l</code> 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称<br><code>-rw-r--r--  1 root  root   2081413 Apr  2  2018 pcre-8.42.tar.gz</code></p><ul><li><code>-</code>：普通文件</li><li><code>rw-</code>：说明用户 root有读写权限，没有运行权限</li><li><code>r--</code>：表示用户组 root只有读权限，没有写和运行的权限</li><li><code>r--</code>：其他用户只有读权限，没有写权限和运行的权限</li></ul><table><thead><tr><th>-rw-r–r–</th><th>1</th><th>root</th><th>root</th><th>2081413</th><th>Apr  2  2018</th><th>pcre-8.42.tar.gz</th></tr></thead><tbody><tr><td>文档类型及权限</td><td>连接数</td><td>文档所属用户</td><td>文档所属组</td><td>文档大小(默认是 bytes)</td><td>文档最后被修改日期</td><td>文档名称</td></tr></tbody></table><table><thead><tr><th>-</th><th>rw-</th><th>r–</th><th>r–</th></tr></thead><tbody><tr><td>文档类型</td><td>文档所有者权限（user）</td><td>文档所属用户组权限（group）</td><td>其他用户权限（other）</td></tr></tbody></table><h2 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h2><ul><li><code>d</code> 表示目录</li><li><code>l</code> 表示软连接</li><li><code>–</code> 表示文件</li><li><code>c</code> 表示串行端口字符设备文件</li><li><code>b</code> 表示可供存储的块设备文件</li><li>余下的字符 3 个字符为一组。r 只读，w 可写，x 可执行，- 表示无此权限</li></ul><h2 id="更改操作权限"><a href="#更改操作权限" class="headerlink" title="更改操作权限"></a>更改操作权限</h2><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组<br><code>chown [-R] 用户名称 文件或者目录</code><br><code>chown [-R] 用户名称 用户组名称 文件或目录</code><br>-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变访问权限<br><code>chmod [who] [+ | - | =] [mode] 文件名</code></p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>表示操作对象可以是以下字母的一个或者组合</p><ul><li>u：用户 user</li><li>g：用户组 group</li><li>o：表示其他用户</li><li>a：表示所有用户是系统默认的</li></ul><h4 id="操作符号"><a href="#操作符号" class="headerlink" title="操作符号"></a>操作符号</h4><ul><li>+：表示添加某个权限</li><li>-：表示取消某个权限</li><li>=：赋予给定的权限，取消文档以前的所有权限</li></ul><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>表示可执行的权限，可以是 r、w、x</p><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文件名可以使空格分开的文件列表</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zedb35jtuqpdgu3bapgz source]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root 4096 Oct 16 15:16 about</span><br><span class="line">[root@iz2zedb35jtuqpdgu3bapgz source]# chmod u-w,g+w about</span><br><span class="line">[root@iz2zedb35jtuqpdgu3bapgz source]# ls -l</span><br><span class="line">dr-xrwxr-x 2 root root 4096 Oct 16 15:16 about</span><br></pre></td></tr></table></figure><h2 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h2><p>数字设定法中数字表示的含义</p><ul><li>0 表示没有任何权限</li><li>1 表示有可执行权限 = x</li><li>2 表示有可写权限 = w</li><li>4 表示有可读权限 = r<br>也可以用数字来表示权限如 <code>chmod 755 file_name</code></li></ul><table><thead><tr><th>r w x</th><th>r – x</th><th>r - x</th></tr></thead><tbody><tr><td>4 2 1</td><td>4 - 1</td><td>4 - 1</td></tr></tbody></table><p>若要 rwx 属性则 4+2+1=7<br>若要 rw- 属性则 4+2=6<br>若要 r-x 属性则 4+1=5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lusifer@UbuntuBase:~$ chmod 777 test.txt </span><br><span class="line">lusifer@UbuntuBase:~$ ls -al test.txt </span><br><span class="line">-rwxrwxrwx 1 lusifer lusifer 6 Nov  2 21:47 test.txt</span><br><span class="line"></span><br><span class="line">lusifer@UbuntuBase:~$ chmod 770 test.txt </span><br><span class="line">lusifer@UbuntuBase:~$ ls -al test.txt </span><br><span class="line">-rwxrwx--- 1 lusifer lusifer 6 Nov  2 21:47 test.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo后台运行</title>
      <link href="/2019/10/24/hexo-background-operation/"/>
      <url>/2019/10/24/hexo-background-operation/</url>
      
        <content type="html"><![CDATA[<p>hexo实现后台运行</p><a id="more"></a><p>在自己服务器上部署好hexo，用 <code>hexo s</code> 启动，默认4000端口就可以访问了，美滋滋！<br>但这不是后台启动，想要再敲命令行或干其他事就需要<code>ctrl+c</code>关掉服务才行。<br>然后看hexo文档给出的后台运行命令是<code>hexo s &amp;</code> ，这样的确可以在后台运行，但是一旦断开ssh链接，hexo就挂了。</p><h3 id="从网上找到了以下几个方案："><a href="#从网上找到了以下几个方案：" class="headerlink" title="从网上找到了以下几个方案："></a>从网上找到了以下几个方案：</h3><ul><li>nodejs的forever插件（<a href="https://segmentfault.com/q/1010000004624987" target="_blank" rel="noopener">启动报错，和这位一样的错</a>）</li><li><code>nohup hexo server  &amp;</code> 命令（断开ssh连接，还是挂了）</li><li>nodejs的pm2 插件（本人采用的方案）<br><img src="https://upload-images.jianshu.io/upload_images/11387217-50eefab747f0b445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><h3 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h3>  npm install -g pm2<h3 id="写一个脚本"><a href="#写一个脚本" class="headerlink" title="写一个脚本"></a>写一个脚本</h3>在博客根目录下创建一个文件 <code>hexo-auto.js</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; exec &#125; = require(&apos;child_process&apos;)</span><br><span class="line">exec(&apos;hexo server&apos;,(error, stdout, stderr) =&gt; &#123;</span><br><span class="line">  if(error)&#123;</span><br><span class="line">    console.log(`exec error: $&#123;error&#125;`)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class="line">  console.log(`stderr: $&#123;stderr&#125;`);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><pre><code>pm2 start hexo-auto.js</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/11387217-25eab71203bf6a69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行成功"></p><p>大功告成，现在即使断开ssh连接依然在后台运行！<br>不过发现个问题，用<code>pm2 stop 0</code>停止这个脚本文件,hexo的服务依然运行着，并且断开ssh连接依然可以访问。<br><img src="https://upload-images.jianshu.io/upload_images/11387217-72c991e9bcc693fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="停止运行"><br>应该是脚本文件还有问题，这个暂时不影响，后续再看是什么问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo nodejs pm2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/17/hello-world/"/>
      <url>/2019/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2019/10/16/first_post/"/>
      <url>/2019/10/16/first_post/</url>
      
        <content type="html"><![CDATA[<p>JDK、JVM底层原理深度解析</p><a id="more"></a><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>jdk 开发环境： 主要功能是编译， 把我们的java文件编译成class文件<br>还有一些工具<br>包含jre，为了完整性，能够有完整的环境。</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>jre 运行时环境：  是包含JVM的。</p><p>Write Once Run EveryWhere    可以运行在任何地方：一次编写，任何有jvm的地方都可以运行。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>jvm的优点：<br>    内存管理：缺点是可能会内存溢出等等。<br>jvm运行时数据区：<br>    数据：<br>        方法区<br>        Heap（堆）<br>    指令：<br>        程序计数器<br>        虚拟机栈<br>        本地方法栈<br>jvm：是将我们编写的代码，在运行时，把不同的东西放到不同的地方，更具指令，做一些运算。</p><h3 id="程序计数器（线程独享）：指当前线程正在执行的字节码指令的地址、行号。"><a href="#程序计数器（线程独享）：指当前线程正在执行的字节码指令的地址、行号。" class="headerlink" title="程序计数器（线程独享）：指当前线程正在执行的字节码指令的地址、行号。"></a>程序计数器（线程独享）：指当前线程正在执行的字节码指令的地址、行号。</h3><p>为什么要用计数器呢？                      </p><pre><code>当线程A在运行时，占用了CPU的时间片，当线程B抢占了CPU的时间片，当线程A再次接着运行时，需要知道要从哪里开始，这个数据就可以从程序计数器拿到了，程序计数器是线程独享的，程序计数器存在哪里？？？？</code></pre><h3 id="虚拟机栈（线程独享）：存储当前线程运行方法所需要的数据、指令、返回地址。-线程独享的。"><a href="#虚拟机栈（线程独享）：存储当前线程运行方法所需要的数据、指令、返回地址。-线程独享的。" class="headerlink" title="虚拟机栈（线程独享）：存储当前线程运行方法所需要的数据、指令、返回地址。   线程独享的。"></a>虚拟机栈（线程独享）：存储当前线程运行方法所需要的数据、指令、返回地址。   线程独享的。</h3><p>写的方法到底是谁来运行的： 线程（线程是一个执行单位),生命周期和线程是相同。</p><p>虚拟机栈中每个出栈、入栈的单位叫做栈帧，每个方法都是一个栈帧，死循环调用方法（递归调用自己，没出口）， 会JVM异常之:栈溢出StackOverflowError </p><h4 id="栈帧里有："><a href="#栈帧里有：" class="headerlink" title="栈帧里有："></a>栈帧里有：</h4><pre><code>局部变量表：存储局部变量的表，编译的时候就能确认大小，运行时才会有数据操作数栈：javap 指令集中   方法中的数据出栈入栈就是存在这个操作数栈中动态链表：多态中，在运行的时候更具字面量（就是变量名）去动态的找实例。出口：try catch   正常return等等 。。。</code></pre><p>每个栈帧都大小都不一样，因为每个方法的参数等等都是不一样的，所以虚拟机栈没有一个固定的大小。</p><h3 id="本地方法栈（线程独享）："><a href="#本地方法栈（线程独享）：" class="headerlink" title="本地方法栈（线程独享）："></a>本地方法栈（线程独享）：</h3><pre><code>用于用于存放本地方法（native method）:貌似是调用的C、C++等等。</code></pre><h3 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h3><pre><code>类信息：生成一个实例时，需要的类的信息。常量（不准确）、静态变量： 存在于方法区JIT（运行时编译的代码，详细百度）：动态代理的信息</code></pre><h3 id="Heap（线程共享）"><a href="#Heap（线程共享）" class="headerlink" title="Heap（线程共享）"></a>Heap（线程共享）</h3><p>JVM的内存模型  JMM<br>    java1.8之前<br>        新生代<br>            eden（十分之八）<br>            s0（十分之一）<br>            s1（十分之一）<br>        老年代<br>        永久代<br>    java1.8之后没有永久代，Meta Space替代永久代，能够解决内存溢出，类似ArrayList，可以扩容；缺点可能会压缩其他地方的空间。</p><p>为什么要分代？</p>]]></content>
      
      
      
        <tags>
            
            <tag> laaa 啊啊 略略 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

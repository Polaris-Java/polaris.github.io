<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux基础知识总结</title>
      <link href="/2019/11/08/linux/"/>
      <url>/2019/11/08/linux/</url>
      
        <content type="html"><![CDATA[<p>Linux基础知识总结</p><a id="more"></a><h1 id="Linux-概述"><a href="#Linux-概述" class="headerlink" title="Linux 概述"></a>Linux 概述</h1><p>Linux 是一种自由和开放源码的类 UNIX 操作系统，使用 Linux 内核。目前存在着许多不同的 Linux 发行版，可安装在各种各样的电脑硬件设备，从手机、平板电脑、路由器和影音游戏控制台，到桌上型电脑，大型电脑和超级电脑。 Linux 是一个领先的操作系统，世界上运算最快的 10 台超级电脑运行的都是 Linux 操作系统。</p><p>Linux 操作系统也是自由软件和开放源代码发展中最著名的例子。只要遵循 GNU 通用公共许可证,任何人和机构都可以自由地使用 Linux 的所有底层源代码，也可以自由地修改和再发布。严格来讲，Linux 这个词本身只表示 Linux 内核，但在实际上人们已经习惯了用 Linux 来形容整个基于 Linux 内核，并且使用 GNU 工程各种工具和数据库的操作系统 (也被称为 GNU/ Linux)。通常情况下，Linux 被打包成供桌上型电脑和服务器使用的 Linux 发行版本。一些流行的主流 Linux 发行版本，包括 Debian (及其衍生版本 Ubuntu)，Fedora 和 OpenSUSE 等。Kernel + Softwares + Tools 就是 Linux Distribution</p><p>目前市面上较知名的发行版有：<strong>Ubuntu</strong>、<strong>Apline</strong> 、RedHat、<strong>CentOS</strong>、Debian、Fedora、SuSE、OpenSUSE、TurboLinux、BluePoint、RedFlag、Xterm、SlackWare等。</p><h1 id="Linux-与-Windows比较"><a href="#Linux-与-Windows比较" class="headerlink" title="Linux 与 Windows比较"></a>Linux 与 Windows比较</h1><p>目前国内 Linux 更多的是应用于服务器上，而桌面操作系统更多使用的是 Windows。主要区别如下：</p><table><thead><tr><th>比较</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>界面</td><td>界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同</td><td>图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致。</td></tr><tr><td>驱动程序</td><td>驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛。</td><td>由志愿者开发，由Linux核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在 Windows 下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解。</td></tr><tr><td>使用</td><td>使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利。</td><td>图形界面使用简单，容易入门。文字界面，需要学习才能掌握。</td></tr><tr><td>学习</td><td>系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难。</td><td>系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易。</td></tr><tr><td>软件</td><td>每一种特定功能可能都需要商业软件的支持，需要购买相应的授权。</td><td>大部分软件都可以自由获取，同样功能的软件选择较少。</td></tr></tbody></table><h1 id="Linux-目录结构"><a href="#Linux-目录结构" class="headerlink" title="Linux 目录结构"></a>Linux 目录结构</h1><p><img src="https://upload-images.jianshu.io/upload_images/11387217-322c432a9d46f820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><table><thead><tr><th>目录</th><th>说明</th></tr></thead><tbody><tr><td>bin</td><td>存放二进制可执行文件(ls,cat,mkdir等)</td></tr><tr><td>boot</td><td>存放用于系统引导时使用的各种文件</td></tr><tr><td>dev</td><td>用于存放设备文件</td></tr><tr><td>etc</td><td>存放系统配置文件</td></tr><tr><td>home</td><td>存放所有用户文件的根目录</td></tr><tr><td>lib</td><td>存放跟文件系统中的程序运行所需要的共享库及内核模块</td></tr><tr><td>mnt</td><td>系统管理员安装临时文件系统的安装点</td></tr><tr><td>opt</td><td>额外安装的可选应用程序包所放置的位置</td></tr><tr><td>proc</td><td>虚拟文件系统，存放当前内存的映射</td></tr><tr><td>root</td><td>超级用户目录</td></tr><tr><td>sbin</td><td>存放二进制可执行文件，只有root才能访问</td></tr><tr><td>tmp</td><td>用于存放各种临时文件</td></tr><tr><td>usr</td><td>用于存放系统应用程序，比较重要的目录/usr/local 本地管理员软件安装目录</td></tr><tr><td>var</td><td>用于存放运行时需要改变数据的文件</td></tr></tbody></table><h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><h2 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h2><table><thead><tr><th>命令</th><th>说明</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>ls</td><td>显示文件和目录列表</td><td>ls [-alrtAFR] [name…]</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-l</td><td>列出文件的详细信息</td></tr><tr><td></td><td></td><td></td><td>-a</td><td>列出当前目录所有文件，包含隐藏文件</td></tr><tr><td>mkdir</td><td>创建目录</td><td>mkdir [-p] dirName</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-p</td><td>父目录不存在情况下先生成父目录</td></tr><tr><td>cd</td><td>切换目录</td><td>cd [dirName]</td><td></td><td></td></tr><tr><td>touch</td><td>生成一个空文件</td><td></td><td></td><td></td></tr><tr><td>echo</td><td>生成一个带内容文件</td><td>echo abcd &gt; 1.txt，echo 1234 &gt;&gt; 1.txt</td><td></td><td></td></tr><tr><td>cat</td><td>显示文本文件内容</td><td>cat [-AbeEnstTuv] [–help] [–version] fileName</td><td></td><td></td></tr><tr><td>cp</td><td>复制文件或目录</td><td>cp [options] source dest</td><td></td><td></td></tr><tr><td>rm</td><td>删除文件</td><td>rm [options] name…</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-f</td><td>强制删除文件或目录</td></tr><tr><td></td><td></td><td></td><td>-r</td><td>同时删除该目录下的所有文件</td></tr><tr><td>mv</td><td>移动文件或目录</td><td>mv [options] source dest</td><td></td><td></td></tr><tr><td>find</td><td>在文件系统中查找指定的文件</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-name</td><td>文件名</td></tr><tr><td>grep</td><td>在指定的文本文件中查找指定的字符串</td><td></td><td></td><td></td></tr><tr><td>tree</td><td>用于以树状图列出目录的内容</td><td></td><td></td><td></td></tr><tr><td>pwd</td><td>显示当前工作目录</td><td></td><td></td><td></td></tr><tr><td>ln</td><td>建立软链接</td><td></td><td></td><td></td></tr><tr><td>more</td><td>分页显示文本文件内容</td><td></td><td></td><td></td></tr><tr><td>head</td><td>显示文件开头内容</td><td></td><td></td><td></td></tr><tr><td>tail</td><td>显示文件结尾内容</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>-f</td><td>跟踪输出</td></tr></tbody></table><h2 id="系统管理命令"><a href="#系统管理命令" class="headerlink" title="系统管理命令"></a>系统管理命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>stat</td><td>显示指定文件的相关信息,比ls命令显示内容更多</td></tr><tr><td>who</td><td>显示在线登录用户</td></tr><tr><td>hostname</td><td>显示主机名称</td></tr><tr><td>uname</td><td>显示系统信息</td></tr><tr><td>top</td><td>显示当前系统中耗费资源最多的进程</td></tr><tr><td>ps</td><td>显示瞬间的进程状态</td></tr><tr><td>du</td><td>显示指定的文件（目录）已使用的磁盘空间的总量</td></tr><tr><td>df</td><td>显示文件系统磁盘空间的使用情况</td></tr><tr><td>free</td><td>显示当前内存和交换空间的使用情况</td></tr><tr><td>ifconfig</td><td>显示网络接口信息</td></tr><tr><td>ping</td><td>测试网络的连通性</td></tr><tr><td>netstat</td><td>显示网络状态信息</td></tr><tr><td>clear</td><td>清屏</td></tr><tr><td>kill</td><td>杀死一个进程</td></tr></tbody></table><h2 id="文件压缩命令"><a href="#文件压缩命令" class="headerlink" title="文件压缩命令"></a>文件压缩命令</h2><table><thead><tr><th>命令</th><th>语法</th><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>tar</td><td>tar [-cxzjvf] 压缩打包文档的名称 欲打包目录</td><td></td><td></td></tr><tr><td></td><td></td><td>-c</td><td>建立一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-x</td><td>解开一个归档文件的参数指令</td></tr><tr><td></td><td></td><td>-z</td><td>是否需要用 gzip 压缩</td></tr><tr><td></td><td></td><td>-j</td><td>是否需要用 bzip2 压缩</td></tr><tr><td></td><td></td><td>-v</td><td>压缩的过程中显示文件</td></tr><tr><td></td><td></td><td>-f</td><td>使用档名，在 f 之后要立即接档名</td></tr><tr><td></td><td></td><td>-tf</td><td>查看归档文件里面的文件</td></tr></tbody></table><h2 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h2><h3 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h3><h4 id="运行模式"><a href="#运行模式" class="headerlink" title="运行模式"></a>运行模式</h4><p>编辑模式：等待编辑命令输入<br>插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息<br>命令模式：在编辑模式下，输入 : 进行命令模式</p><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><p><code>:q</code> 直接退出vi<br><code>:wq</code> 保存后退出vi ，并可以新建文件<br><code>:q!</code> 强制退出<br><code>:w file</code> 将当前内容保存成某个文件<br><code>:set number</code> 在编辑文件显示行号<br><code>:set nonumber</code> 在编辑文件不显示行号</p><h1 id="Linux文件权限管理"><a href="#Linux文件权限管理" class="headerlink" title="Linux文件权限管理"></a>Linux文件权限管理</h1><h2 id="查看文件和目录的权限"><a href="#查看文件和目录的权限" class="headerlink" title="查看文件和目录的权限"></a>查看文件和目录的权限</h2><p><code>ls –al</code>使用 ls 不带参数只显示文件名称，通过<code>ls –al</code> 可以显示文件或者目录的权限信息。<br><code>ls -l 文件名</code> 显示信息包括：文件类型 (<code>d</code>目录，<code>-</code> 普通文件，<code>l</code> 链接文件)，文件权限，文件的用户，文件的所属组，文件的大小，文件的创建时间，文件的名称<br><code>-rw-r--r--  1 root  root   2081413 Apr  2  2018 pcre-8.42.tar.gz</code></p><ul><li><code>-</code>：普通文件</li><li><code>rw-</code>：说明用户 root有读写权限，没有运行权限</li><li><code>r--</code>：表示用户组 root只有读权限，没有写和运行的权限</li><li><code>r--</code>：其他用户只有读权限，没有写权限和运行的权限</li></ul><table><thead><tr><th>-rw-r–r–</th><th>1</th><th>root</th><th>root</th><th>2081413</th><th>Apr  2  2018</th><th>pcre-8.42.tar.gz</th></tr></thead><tbody><tr><td>文档类型及权限</td><td>连接数</td><td>文档所属用户</td><td>文档所属组</td><td>文档大小(默认是 bytes)</td><td>文档最后被修改日期</td><td>文档名称</td></tr></tbody></table><table><thead><tr><th>-</th><th>rw-</th><th>r–</th><th>r–</th></tr></thead><tbody><tr><td>文档类型</td><td>文档所有者权限（user）</td><td>文档所属用户组权限（group）</td><td>其他用户权限（other）</td></tr></tbody></table><h2 id="文档类型"><a href="#文档类型" class="headerlink" title="文档类型"></a>文档类型</h2><ul><li><code>d</code> 表示目录</li><li><code>l</code> 表示软连接</li><li><code>–</code> 表示文件</li><li><code>c</code> 表示串行端口字符设备文件</li><li><code>b</code> 表示可供存储的块设备文件</li><li>余下的字符 3 个字符为一组。r 只读，w 可写，x 可执行，- 表示无此权限</li></ul><h2 id="更改操作权限"><a href="#更改操作权限" class="headerlink" title="更改操作权限"></a>更改操作权限</h2><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>是 change owner 的意思，主要作用就是改变文件或者目录所有者，所有者包含用户和用户组<br><code>chown [-R] 用户名称 文件或者目录</code><br><code>chown [-R] 用户名称 用户组名称 文件或目录</code><br>-R：进行递归式的权限更改，将目录下的所有文件、子目录更新为指定用户组权限</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>改变访问权限<br><code>chmod [who] [+ | - | =] [mode] 文件名</code></p><h4 id="who"><a href="#who" class="headerlink" title="who"></a>who</h4><p>表示操作对象可以是以下字母的一个或者组合</p><ul><li>u：用户 user</li><li>g：用户组 group</li><li>o：表示其他用户</li><li>a：表示所有用户是系统默认的</li></ul><h4 id="操作符号"><a href="#操作符号" class="headerlink" title="操作符号"></a>操作符号</h4><ul><li>+：表示添加某个权限</li><li>-：表示取消某个权限</li><li>=：赋予给定的权限，取消文档以前的所有权限</li></ul><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>表示可执行的权限，可以是 r、w、x</p><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>文件名可以使空格分开的文件列表</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zedb35jtuqpdgu3bapgz source]# ls -l</span><br><span class="line">drwxr-xr-x 2 root root 4096 Oct 16 15:16 about</span><br><span class="line">[root@iz2zedb35jtuqpdgu3bapgz source]# chmod u-w,g+w about</span><br><span class="line">[root@iz2zedb35jtuqpdgu3bapgz source]# ls -l</span><br><span class="line">dr-xrwxr-x 2 root root 4096 Oct 16 15:16 about</span><br></pre></td></tr></table></figure><h2 id="数字设定法"><a href="#数字设定法" class="headerlink" title="数字设定法"></a>数字设定法</h2><p>数字设定法中数字表示的含义</p><ul><li>0 表示没有任何权限</li><li>1 表示有可执行权限 = x</li><li>2 表示有可写权限 = w</li><li>4 表示有可读权限 = r<br>也可以用数字来表示权限如 <code>chmod 755 file_name</code></li></ul><table><thead><tr><th>r w x</th><th>r – x</th><th>r - x</th></tr></thead><tbody><tr><td>4 2 1</td><td>4 - 1</td><td>4 - 1</td></tr></tbody></table><p>若要 rwx 属性则 4+2+1=7<br>若要 rw- 属性则 4+2=6<br>若要 r-x 属性则 4+1=5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lusifer@UbuntuBase:~$ chmod 777 test.txt </span><br><span class="line">lusifer@UbuntuBase:~$ ls -al test.txt </span><br><span class="line">-rwxrwxrwx 1 lusifer lusifer 6 Nov  2 21:47 test.txt</span><br><span class="line"></span><br><span class="line">lusifer@UbuntuBase:~$ chmod 770 test.txt </span><br><span class="line">lusifer@UbuntuBase:~$ ls -al test.txt </span><br><span class="line">-rwxrwx--- 1 lusifer lusifer 6 Nov  2 21:47 test.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo后台运行</title>
      <link href="/2019/10/24/hexo-background-operation/"/>
      <url>/2019/10/24/hexo-background-operation/</url>
      
        <content type="html"><![CDATA[<p>hexo实现后台运行</p><a id="more"></a><p>在自己服务器上部署好hexo，用 <code>hexo s</code> 启动，默认4000端口就可以访问了，美滋滋！<br>但这不是后台启动，想要再敲命令行或干其他事就需要<code>ctrl+c</code>关掉服务才行。<br>然后看hexo文档给出的后台运行命令是<code>hexo s &amp;</code> ，这样的确可以在后台运行，但是一旦断开ssh链接，hexo就挂了。</p><h3 id="从网上找到了以下几个方案："><a href="#从网上找到了以下几个方案：" class="headerlink" title="从网上找到了以下几个方案："></a>从网上找到了以下几个方案：</h3><ul><li>nodejs的forever插件（<a href="https://segmentfault.com/q/1010000004624987" target="_blank" rel="noopener">启动报错，和这位一样的错</a>）</li><li><code>nohup hexo server  &amp;</code> 命令（断开ssh连接，还是挂了）</li><li>nodejs的pm2 插件（本人采用的方案）<br><img src="https://upload-images.jianshu.io/upload_images/11387217-50eefab747f0b445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><h3 id="安装pm2"><a href="#安装pm2" class="headerlink" title="安装pm2"></a>安装pm2</h3>  npm install -g pm2<h3 id="写一个脚本"><a href="#写一个脚本" class="headerlink" title="写一个脚本"></a>写一个脚本</h3>在博客根目录下创建一个文件 <code>hexo-auto.js</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; exec &#125; = require(&apos;child_process&apos;)</span><br><span class="line">exec(&apos;hexo server&apos;,(error, stdout, stderr) =&gt; &#123;</span><br><span class="line">  if(error)&#123;</span><br><span class="line">    console.log(`exec error: $&#123;error&#125;`)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`stdout: $&#123;stdout&#125;`);</span><br><span class="line">  console.log(`stderr: $&#123;stderr&#125;`);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><pre><code>pm2 start hexo-auto.js</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/11387217-25eab71203bf6a69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行成功"></p><p>大功告成，现在即使断开ssh连接依然在后台运行！<br>不过发现个问题，用<code>pm2 stop 0</code>停止这个脚本文件,hexo的服务依然运行着，并且断开ssh连接依然可以访问。<br><img src="https://upload-images.jianshu.io/upload_images/11387217-72c991e9bcc693fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="停止运行"><br>应该是脚本文件还有问题，这个暂时不影响，后续再看是什么问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo nodejs pm2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/10/17/hello-world/"/>
      <url>/2019/10/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2019/10/16/first_post/"/>
      <url>/2019/10/16/first_post/</url>
      
        <content type="html"><![CDATA[<p>JDK、JVM底层原理深度解析</p><a id="more"></a><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>jdk 开发环境： 主要功能是编译， 把我们的java文件编译成class文件<br>还有一些工具<br>包含jre，为了完整性，能够有完整的环境。</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>jre 运行时环境：  是包含JVM的。</p><p>Write Once Run EveryWhere    可以运行在任何地方：一次编写，任何有jvm的地方都可以运行。</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>jvm的优点：<br>    内存管理：缺点是可能会内存溢出等等。<br>jvm运行时数据区：<br>    数据：<br>        方法区<br>        Heap（堆）<br>    指令：<br>        程序计数器<br>        虚拟机栈<br>        本地方法栈<br>jvm：是将我们编写的代码，在运行时，把不同的东西放到不同的地方，更具指令，做一些运算。</p><h3 id="程序计数器（线程独享）：指当前线程正在执行的字节码指令的地址、行号。"><a href="#程序计数器（线程独享）：指当前线程正在执行的字节码指令的地址、行号。" class="headerlink" title="程序计数器（线程独享）：指当前线程正在执行的字节码指令的地址、行号。"></a>程序计数器（线程独享）：指当前线程正在执行的字节码指令的地址、行号。</h3><p>为什么要用计数器呢？                      </p><pre><code>当线程A在运行时，占用了CPU的时间片，当线程B抢占了CPU的时间片，当线程A再次接着运行时，需要知道要从哪里开始，这个数据就可以从程序计数器拿到了，程序计数器是线程独享的，程序计数器存在哪里？？？？</code></pre><h3 id="虚拟机栈（线程独享）：存储当前线程运行方法所需要的数据、指令、返回地址。-线程独享的。"><a href="#虚拟机栈（线程独享）：存储当前线程运行方法所需要的数据、指令、返回地址。-线程独享的。" class="headerlink" title="虚拟机栈（线程独享）：存储当前线程运行方法所需要的数据、指令、返回地址。   线程独享的。"></a>虚拟机栈（线程独享）：存储当前线程运行方法所需要的数据、指令、返回地址。   线程独享的。</h3><p>写的方法到底是谁来运行的： 线程（线程是一个执行单位),生命周期和线程是相同。</p><p>虚拟机栈中每个出栈、入栈的单位叫做栈帧，每个方法都是一个栈帧，死循环调用方法（递归调用自己，没出口）， 会JVM异常之:栈溢出StackOverflowError </p><h4 id="栈帧里有："><a href="#栈帧里有：" class="headerlink" title="栈帧里有："></a>栈帧里有：</h4><pre><code>局部变量表：存储局部变量的表，编译的时候就能确认大小，运行时才会有数据操作数栈：javap 指令集中   方法中的数据出栈入栈就是存在这个操作数栈中动态链表：多态中，在运行的时候更具字面量（就是变量名）去动态的找实例。出口：try catch   正常return等等 。。。</code></pre><p>每个栈帧都大小都不一样，因为每个方法的参数等等都是不一样的，所以虚拟机栈没有一个固定的大小。</p><h3 id="本地方法栈（线程独享）："><a href="#本地方法栈（线程独享）：" class="headerlink" title="本地方法栈（线程独享）："></a>本地方法栈（线程独享）：</h3><pre><code>用于用于存放本地方法（native method）:貌似是调用的C、C++等等。</code></pre><h3 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h3><pre><code>类信息：生成一个实例时，需要的类的信息。常量（不准确）、静态变量： 存在于方法区JIT（运行时编译的代码，详细百度）：动态代理的信息</code></pre><h3 id="Heap（线程共享）"><a href="#Heap（线程共享）" class="headerlink" title="Heap（线程共享）"></a>Heap（线程共享）</h3><p>JVM的内存模型  JMM<br>    java1.8之前<br>        新生代<br>            eden（十分之八）<br>            s0（十分之一）<br>            s1（十分之一）<br>        老年代<br>        永久代<br>    java1.8之后没有永久代，Meta Space替代永久代，能够解决内存溢出，类似ArrayList，可以扩容；缺点可能会压缩其他地方的空间。</p><p>为什么要分代？</p>]]></content>
      
      
      
        <tags>
            
            <tag> laaa 啊啊 略略 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

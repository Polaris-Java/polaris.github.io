<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta name="referrer" content="no-referrer">
  
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>
    Java_Reflect反射详解 |
    
    北极星</title>
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">
  
  <script src="/js/pace.min.js"></script>
</head>
</html>
<body>
<main class="content">
  <section class="outer">
  

<article id="post-Java-Reflect" class="article article-type-post" itemscope itemprop="blogPost" data-scroll-reveal>
  
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java_Reflect反射详解
    </h1>
  
  




      </header>
    

    
      <div class="article-meta">
        <a href="/2020/01/06/Java-Reflect/" class="article-date">
  <time datetime="2020-01-06T15:13:17.000Z" itemprop="datePublished">2020-01-06</time>
</a>
        
      </div>
    

    
      
    <div class="tocbot"></div>





    

    <div class="article-entry" itemprop="articleBody">
      


      
  <div class="article-gallery">
    <div class="article-gallery-photos">
      
        
          <img src="https://w.wallhaven.cc/full/73/wallhaven-73o1oy.jpg" itemprop="image">
        
      
    </div>
  </div>


      
        <p>Java 反射详解！</p>
<a id="more"></a>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="一、反射的概述"><a href="#一、反射的概述" class="headerlink" title="一、反射的概述"></a>一、反射的概述</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p><strong>总结：反射就是Java在运行时才知道要操作的类什么，并且可以在运行时获取类的完整构造（方法、属性、构造函数…），并可以调用所有的方法</strong></p>
<p>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象.</p>
<p>如图是类的正常加载过程：</p>
<p>反射的原理就在于class对象，Class对象的由来是：JVM将class文件读入内存时，并为之创建一个Class对象。</p>
<p><img src="https://img-blog.csdn.net/20170513133210763" alt="类的加载过程"></p>
<p>其中Class对象在反射中很重要，所以我们先来了解一下Class对象</p>
<h2 id="二、Class的概述"><a href="#二、Class的概述" class="headerlink" title="二、Class的概述"></a>二、Class的概述</h2><p><img src="https://img-blog.csdn.net/20170513135521667" alt="class类"></p>
<p>Class 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）</p>
<p>Class 没有公共构造方法。Class 对象是在加载类时由Java虚拟机以及通过调用类加载器中的defineClass方法自动构造的。也就是这不需要我们自己去处理创建，JVM已经帮我们创建好了。</p>
<p>没有公共的构造方法，方法共有64个太多了。下面用到哪个就详解哪个吧</p>
<p><img src="https://img-blog.csdn.net/20170513144141409" alt="class类的方法"></p>
<h2 id="三、反射的使用"><a href="#三、反射的使用" class="headerlink" title="三、反射的使用"></a>三、反射的使用</h2><h3 id="1-获取Class对象的三种方式"><a href="#1-获取Class对象的三种方式" class="headerlink" title="1.获取Class对象的三种方式"></a>1.获取Class对象的三种方式</h3><p>在反射中，要获取一个类或调用一个类的方法，我们首先需要获取到该类的 Class 对象。</p>
<p>在 Java API 中，获取 Class 类对象有三种方法：</p>
<p>第一种，使用 Class.forName 静态方法。当你知道该类的全路径名时，你可以使用该方法获取 Class 类对象；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = Class.getName(&quot;com.siweisoft.model.User&quot;);</span><br></pre></td></tr></table></figure>

<p>第二种，使用类对象的 getClass() 方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = new User(();</span><br><span class="line">Class clazz = user.getClass;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20170513145317647" alt="Object的getClass()"></p>
<p>第三种，使用类的.class属性；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class clazz = User.class;</span><br></pre></td></tr></table></figure>

<p><strong>在运行期间，一个类，只有一个对象</strong></p>
<h3 id="2-通过反射创建类对象"><a href="#2-通过反射创建类对象" class="headerlink" title="2.通过反射创建类对象"></a>2.通过反射创建类对象</h3><p>第一种：通过 Class 对象的 newInstance() 方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Apple apple = (Apple)clz.newInstance();</span><br></pre></td></tr></table></figure>

<p>第二种：通过 Constructor 对象的 newInstance() 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Constructor constructor = clz.getConstructor();</span><br><span class="line">Apple apple = (Apple)constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>通过 Constructor 对象创建类对象可以选择特定构造方法，而通过 Class 对象则只能使用默认的无参数构造方法。下面的代码就调用了一个有参数的构造方法进行了类对象的初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class clz = Apple.class;</span><br><span class="line">Constructor constructor = clz.getConstructor(String.class, int.class);</span><br><span class="line">Apple apple = (Apple)constructor.newInstance(&quot;红富士&quot;, 15);</span><br></pre></td></tr></table></figure>

<h3 id="3-获取构造函数"><a href="#3-获取构造函数" class="headerlink" title="3.获取构造函数"></a>3.获取构造函数</h3><p>Student类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package fanshe;</span><br><span class="line"> </span><br><span class="line">public class Student &#123;</span><br><span class="line">	</span><br><span class="line">	//---------------构造方法-------------------</span><br><span class="line">	//（默认的构造方法）</span><br><span class="line">	Student(String str)&#123;</span><br><span class="line">		System.out.println(&quot;(默认)的构造方法 s = &quot; + str);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//无参构造方法</span><br><span class="line">	public Student()&#123;</span><br><span class="line">		System.out.println(&quot;调用了公有、无参构造方法执行了。。。&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//有一个参数的构造方法</span><br><span class="line">	public Student(char name)&#123;</span><br><span class="line">		System.out.println(&quot;姓名：&quot; + name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//有多个参数的构造方法</span><br><span class="line">	public Student(String name ,int age)&#123;</span><br><span class="line">		System.out.println(&quot;姓名：&quot;+name+&quot;年龄：&quot;+ age);//这的执行效率有问题，以后解决。</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//受保护的构造方法</span><br><span class="line">	protected Student(boolean n)&#123;</span><br><span class="line">		System.out.println(&quot;受保护的构造方法 n = &quot; + n);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//私有构造方法</span><br><span class="line">	private Student(int age)&#123;</span><br><span class="line">		System.out.println(&quot;私有的构造方法   年龄：&quot;+ age);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共有6个构造方法：</p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package fanshe;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；</span><br><span class="line"> * </span><br><span class="line"> * 1.获取构造方法：</span><br><span class="line"> * 		1).批量的方法：</span><br><span class="line"> * 			public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法</span><br><span class="line">            public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line">     </span><br><span class="line"> * 		2).获取单个的方法，并调用：</span><br><span class="line"> * 			public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：</span><br><span class="line"> * 			public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line"> * 		</span><br><span class="line"> * 			调用构造方法：</span><br><span class="line"> * 			Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line"> */</span><br><span class="line">public class Constructors &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		//1.加载Class对象</span><br><span class="line">		Class clazz = Class.forName(&quot;fanshe.Student&quot;);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		//2.获取所有公有构造方法</span><br><span class="line">		System.out.println(&quot;**********************所有公有构造方法*********************************&quot;);</span><br><span class="line">		Constructor[] conArray = clazz.getConstructors();</span><br><span class="line">		for(Constructor c : conArray)&#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;************所有的构造方法(包括：私有、受保护、默认、公有)***************&quot;);</span><br><span class="line">		conArray = clazz.getDeclaredConstructors();</span><br><span class="line">		for(Constructor c : conArray)&#123;</span><br><span class="line">			System.out.println(c);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;*****************获取公有、无参的构造方法*******************************&quot;);</span><br><span class="line">		Constructor con = clazz.getConstructor(null);</span><br><span class="line">		//1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型</span><br><span class="line">		//2&gt;、返回的是描述这个无参构造函数的类对象。</span><br><span class="line">	</span><br><span class="line">		System.out.println(&quot;con = &quot; + con);</span><br><span class="line">		//调用构造方法</span><br><span class="line">		Object obj = con.newInstance();</span><br><span class="line">	//	System.out.println(&quot;obj = &quot; + obj);</span><br><span class="line">	//	Student stu = (Student)obj;</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;******************获取私有构造方法，并调用*******************************&quot;);</span><br><span class="line">		con = clazz.getDeclaredConstructor(char.class);</span><br><span class="line">		System.out.println(con);</span><br><span class="line">		//调用构造方法</span><br><span class="line">		con.setAccessible(true);//暴力访问(忽略掉访问修饰符)</span><br><span class="line">		obj = con.newInstance(&apos;男&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**********************所有公有构造方法*********************************</span><br><span class="line">public fanshe.Student(java.lang.String,int)</span><br><span class="line">public fanshe.Student(char)</span><br><span class="line">public fanshe.Student()</span><br><span class="line">************所有的构造方法(包括：私有、受保护、默认、公有)***************</span><br><span class="line">private fanshe.Student(int)</span><br><span class="line">protected fanshe.Student(boolean)</span><br><span class="line">public fanshe.Student(java.lang.String,int)</span><br><span class="line">public fanshe.Student(char)</span><br><span class="line">public fanshe.Student()</span><br><span class="line">fanshe.Student(java.lang.String)</span><br><span class="line">*****************获取公有、无参的构造方法*******************************</span><br><span class="line">con = public fanshe.Student()</span><br><span class="line">调用了公有、无参构造方法执行了。。。</span><br><span class="line">******************获取私有构造方法，并调用*******************************</span><br><span class="line">public fanshe.Student(char)</span><br><span class="line">姓名：男</span><br></pre></td></tr></table></figure>

<p>调用的api：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">批量的方法：</span><br><span class="line">public Constructor[] getConstructors()：所有&quot;公有的&quot;构造方法</span><br><span class="line">public Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)</span><br><span class="line"></span><br><span class="line">获取单个的方法，并调用：</span><br><span class="line">public Constructor getConstructor(Class... parameterTypes):获取单个的&quot;公有的&quot;构造方法：</span><br><span class="line">public Constructor getDeclaredConstructor(Class... parameterTypes):获取&quot;某个构造方法&quot;可以是私有的，或受保护、默认、公有；</span><br><span class="line"></span><br><span class="line">调用构造方法：</span><br><span class="line">Constructor--&gt;newInstance(Object... initargs)</span><br><span class="line"></span><br><span class="line">newInstance(Object... initargs)是 Constructor类的方法（管理构造函数的类）</span><br><span class="line">使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</span><br><span class="line">它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</span><br></pre></td></tr></table></figure>

<h3 id="4-获取成员变量并调用"><a href="#4-获取成员变量并调用" class="headerlink" title="4.获取成员变量并调用"></a>4.获取成员变量并调用</h3><p>student类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package fanshe.field;</span><br><span class="line"> </span><br><span class="line">public class Student &#123;</span><br><span class="line">	public Student()&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	//**********字段*************//</span><br><span class="line">	public String name;</span><br><span class="line">	protected int age;</span><br><span class="line">	char sex;</span><br><span class="line">	private String phoneNum;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public String toString() &#123;</span><br><span class="line">		return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;, sex=&quot; + sex</span><br><span class="line">				+ &quot;, phoneNum=&quot; + phoneNum + &quot;]&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package fanshe.field;</span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line">/*</span><br><span class="line"> * 获取成员变量并调用：</span><br><span class="line"> * </span><br><span class="line"> * 1.批量的</span><br><span class="line"> * 		1).Field[] getFields():获取所有的&quot;公有字段&quot;</span><br><span class="line"> * 		2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；</span><br><span class="line"> * 2.获取单个的：</span><br><span class="line"> * 		1).public Field getField(String fieldName):获取某个&quot;公有的&quot;字段；</span><br><span class="line"> * 		2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的)</span><br><span class="line"> * </span><br><span class="line"> * 	 设置字段的值：</span><br><span class="line"> * 		Field --&gt; public void set(Object obj,Object value):</span><br><span class="line"> * 					参数说明：</span><br><span class="line"> * 					1.obj:要设置的字段所在的对象；</span><br><span class="line"> * 					2.value:要为字段设置的值；</span><br><span class="line"> * </span><br><span class="line"> */</span><br><span class="line">public class Fields &#123;</span><br><span class="line"> </span><br><span class="line">		public static void main(String[] args) throws Exception &#123;</span><br><span class="line">			//1.获取Class对象</span><br><span class="line">			Class stuClass = Class.forName(&quot;fanshe.field.Student&quot;);</span><br><span class="line">			//2.获取字段</span><br><span class="line">			System.out.println(&quot;************获取所有公有的字段********************&quot;);</span><br><span class="line">			Field[] fieldArray = stuClass.getFields();</span><br><span class="line">			for(Field f : fieldArray)&#123;</span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;************获取所有的字段(包括私有、受保护、默认的)********************&quot;);</span><br><span class="line">			fieldArray = stuClass.getDeclaredFields();</span><br><span class="line">			for(Field f : fieldArray)&#123;</span><br><span class="line">				System.out.println(f);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(&quot;*************获取公有字段**并调用***********************************&quot;);</span><br><span class="line">			Field f = stuClass.getField(&quot;name&quot;);</span><br><span class="line">			System.out.println(f);</span><br><span class="line">			//获取一个对象</span><br><span class="line">			Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();</span><br><span class="line">			//为字段设置值</span><br><span class="line">			f.set(obj, &quot;刘德华&quot;);//为Student对象中的name属性赋值--》stu.name = &quot;刘德华&quot;</span><br><span class="line">			//验证</span><br><span class="line">			Student stu = (Student)obj;</span><br><span class="line">			System.out.println(&quot;验证姓名：&quot; + stu.name);</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			System.out.println(&quot;**************获取私有字段****并调用********************************&quot;);</span><br><span class="line">			f = stuClass.getDeclaredField(&quot;phoneNum&quot;);</span><br><span class="line">			System.out.println(f);</span><br><span class="line">			f.setAccessible(true);//暴力反射，解除私有限定</span><br><span class="line">			f.set(obj, &quot;18888889999&quot;);</span><br><span class="line">			System.out.println(&quot;验证电话：&quot; + stu);</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">************获取所有公有的字段********************</span><br><span class="line">public java.lang.String fanshe.field.Student.name</span><br><span class="line">************获取所有的字段(包括私有、受保护、默认的)********************</span><br><span class="line">public java.lang.String fanshe.field.Student.name</span><br><span class="line">protected int fanshe.field.Student.age</span><br><span class="line">char fanshe.field.Student.sex</span><br><span class="line">private java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">*************获取公有字段**并调用***********************************</span><br><span class="line">public java.lang.String fanshe.field.Student.name</span><br><span class="line">验证姓名：刘德华</span><br><span class="line">**************获取私有字段****并调用********************************</span><br><span class="line">private java.lang.String fanshe.field.Student.phoneNum</span><br><span class="line">验证电话：Student [name=刘德华, age=0, sex=</span><br></pre></td></tr></table></figure>

<h3 id="5-获取成员方法并调用"><a href="#5-获取成员方法并调用" class="headerlink" title="5.获取成员方法并调用"></a>5.获取成员方法并调用</h3><p>student类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package fanshe.method;</span><br><span class="line"> </span><br><span class="line">public class Student &#123;</span><br><span class="line">	//**************成员方法***************//</span><br><span class="line">	public void show1(String s)&#123;</span><br><span class="line">		System.out.println(&quot;调用了：公有的，String参数的show1(): s = &quot; + s);</span><br><span class="line">	&#125;</span><br><span class="line">	protected void show2()&#123;</span><br><span class="line">		System.out.println(&quot;调用了：受保护的，无参的show2()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	void show3()&#123;</span><br><span class="line">		System.out.println(&quot;调用了：默认的，无参的show3()&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	private String show4(int age)&#123;</span><br><span class="line">		System.out.println(&quot;调用了，私有的，并且有返回值的，int参数的show4(): age = &quot; + age);</span><br><span class="line">		return &quot;abcd&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package fanshe.method;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 获取成员方法并调用：</span><br><span class="line"> * </span><br><span class="line"> * 1.批量的：</span><br><span class="line"> * 		public Method[] getMethods():获取所有&quot;公有方法&quot;；（包含了父类的方法也包含Object类）</span><br><span class="line"> * 		public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的)</span><br><span class="line"> * 2.获取单个的：</span><br><span class="line"> * 		public Method getMethod(String name,Class&lt;?&gt;... parameterTypes):</span><br><span class="line"> * 					参数：</span><br><span class="line"> * 						name : 方法名；</span><br><span class="line"> * 						Class ... : 形参的Class类型对象</span><br><span class="line"> * 		public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes)</span><br><span class="line"> * </span><br><span class="line"> * 	 调用方法：</span><br><span class="line"> * 		Method --&gt; public Object invoke(Object obj,Object... args):</span><br><span class="line"> * 					参数说明：</span><br><span class="line"> * 					obj : 要调用方法的对象；</span><br><span class="line"> * 					args:调用方式时所传递的实参；</span><br><span class="line">):</span><br><span class="line"> */</span><br><span class="line">public class MethodClass &#123;</span><br><span class="line"> </span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		//1.获取Class对象</span><br><span class="line">		Class stuClass = Class.forName(&quot;fanshe.method.Student&quot;);</span><br><span class="line">		//2.获取所有公有方法</span><br><span class="line">		System.out.println(&quot;***************获取所有的”公有“方法*******************&quot;);</span><br><span class="line">		stuClass.getMethods();</span><br><span class="line">		Method[] methodArray = stuClass.getMethods();</span><br><span class="line">		for(Method m : methodArray)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;***************获取所有的方法，包括私有的*******************&quot;);</span><br><span class="line">		methodArray = stuClass.getDeclaredMethods();</span><br><span class="line">		for(Method m : methodArray)&#123;</span><br><span class="line">			System.out.println(m);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(&quot;***************获取公有的show1()方法*******************&quot;);</span><br><span class="line">		Method m = stuClass.getMethod(&quot;show1&quot;, String.class);</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		//实例化一个Student对象</span><br><span class="line">		Object obj = stuClass.getConstructor().newInstance();</span><br><span class="line">		m.invoke(obj, &quot;刘德华&quot;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;***************获取私有的show4()方法******************&quot;);</span><br><span class="line">		m = stuClass.getDeclaredMethod(&quot;show4&quot;, int.class);</span><br><span class="line">		System.out.println(m);</span><br><span class="line">		m.setAccessible(true);//解除私有限定</span><br><span class="line">		Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参</span><br><span class="line">		System.out.println(&quot;返回值：&quot; + result);</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">***************获取所有的”公有“方法*******************</span><br><span class="line">public void fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span><br><span class="line">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span><br><span class="line">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span><br><span class="line">public boolean java.lang.Object.equals(java.lang.Object)</span><br><span class="line">public java.lang.String java.lang.Object.toString()</span><br><span class="line">public native int java.lang.Object.hashCode()</span><br><span class="line">public final native java.lang.Class java.lang.Object.getClass()</span><br><span class="line">public final native void java.lang.Object.notify()</span><br><span class="line">public final native void java.lang.Object.notifyAll()</span><br><span class="line">***************获取所有的方法，包括私有的*******************</span><br><span class="line">public void fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">private java.lang.String fanshe.method.Student.show4(int)</span><br><span class="line">protected void fanshe.method.Student.show2()</span><br><span class="line">void fanshe.method.Student.show3()</span><br><span class="line">***************获取公有的show1()方法*******************</span><br><span class="line">public void fanshe.method.Student.show1(java.lang.String)</span><br><span class="line">调用了：公有的，String参数的show1(): s = 刘德华</span><br><span class="line">***************获取私有的show4()方法******************</span><br><span class="line">private java.lang.String fanshe.method.Student.show4(int)</span><br><span class="line">调用了，私有的，并且有返回值的，int参数的show4(): age = 20</span><br><span class="line">返回值：abcd</span><br></pre></td></tr></table></figure>

<h3 id="6-反射方法的其它使用之—通过反射越过泛型检查"><a href="#6-反射方法的其它使用之—通过反射越过泛型检查" class="headerlink" title="6.反射方法的其它使用之—通过反射越过泛型检查"></a>6.反射方法的其它使用之—通过反射越过泛型检查</h3><p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的</p>
<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 通过反射越过泛型检查</span><br><span class="line"> * </span><br><span class="line"> * 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？</span><br><span class="line"> */</span><br><span class="line">public class Demo &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();</span><br><span class="line">		strList.add(&quot;aaa&quot;);</span><br><span class="line">		strList.add(&quot;bbb&quot;);</span><br><span class="line">		</span><br><span class="line">	//	strList.add(100);</span><br><span class="line">		//获取ArrayList的Class对象，反向的调用add()方法，添加数据</span><br><span class="line">		Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象</span><br><span class="line">		//获取add()方法</span><br><span class="line">		Method m = listClass.getMethod(&quot;add&quot;, Object.class);</span><br><span class="line">		//调用add()方法</span><br><span class="line">		m.invoke(strList, 100);</span><br><span class="line">		</span><br><span class="line">		//遍历集合</span><br><span class="line">		for(Object obj : strList)&#123;</span><br><span class="line">			System.out.println(obj);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="反射的源码解析"><a href="#反射的源码解析" class="headerlink" title="反射的源码解析"></a>反射的源码解析</h2><p>当我们懂得了如何使用反射后，今天我们就来看看 JDK 源码中是如何实现反射的。或许大家平时没有使用过反射，但是在开发 Web 项目的时候会遇到过下面的异常：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException </span><br><span class="line">...</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">  at java.lang.reflect.Method.invoke(Method.java:497)</span><br></pre></td></tr></table></figure>

<p>可以看到异常堆栈指出了异常在 Method 的第 497 的 invoke 方法中，其实这里指的 invoke 方法就是我们反射调用方法中的 invoke。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method method = clz.getMethod(&quot;setPrice&quot;, int.class); </span><br><span class="line">method.invoke(object, 4);   //就是这里的invoke方法</span><br></pre></td></tr></table></figure>

<p>例如我们经常使用的 Spring 配置中，经常会有相关 Bean 的配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;com.chenshuyi.Apple&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>当我们在 XML 文件中配置了上面这段配置之后，Spring 便会在启动的时候利用反射去加载对应的 Apple 类。而当 Apple 类不存在或发生启发异常时，异常堆栈便会将异常指向调用的 invoke 方法。</p>
<p>从这里可以看出，我们平常很多框架都使用了反射，而反射中最最终的就是 Method 类的 invoke 方法了。</p>
<p>下面我们来看看 JDK 的 invoke 方法到底做了些什么。</p>
<p>进入 Method 的 invoke 方法我们可以看到，一开始是进行了一些权限的检查，最后是调用了 MethodAccessor 类的 invoke 方法进行进一步处理，如下图红色方框所示。</p>
<p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000148605-1162314142.png" alt="MethodAccessor类的invoke"></p>
<p>那么 MethodAccessor 又是什么呢？</p>
<p>其实 MethodAccessor 是一个接口，定义了方法调用的具体操作，而它有三个具体的实现类：</p>
<p>sun.reflect.DelegatingMethodAccessorImpl<br>sun.reflect.MethodAccessorImpl<br>sun.reflect.NativeMethodAccessorImpl<br>而要看 ma.invoke() 到底调用的是哪个类的 invoke 方法，则需要看看 MethodAccessor 对象返回的到底是哪个类对象，所以我们需要进入 acquireMethodAccessor() 方法中看看。</p>
<p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000158770-762759003.png" alt="acquireMethodAccessor()"></p>
<p>从 acquireMethodAccessor() 方法我们可以看到，代码先判断是否存在对应的 MethodAccessor 对象，如果存在那么就复用之前的 MethodAccessor 对象，否则调用 ReflectionFactory 对象的 newMethodAccessor 方法生成一个 MethodAccessor 对象。</p>
<p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000210324-586245969.png" alt="image"></p>
<p>在 ReflectionFactory 类的 newMethodAccessor 方法里，我们可以看到首先是生成了一个 NativeMethodAccessorImpl 对象，再这个对象作为参数调用 DelegatingMethodAccessorImpl 类的构造方法。</p>
<p>这里的实现是使用了代理模式，将 NativeMethodAccessorImpl 对象交给 DelegatingMethodAccessorImpl 对象代理。我们查看 DelegatingMethodAccessorImpl 类的构造方法可以知道，其实是将 NativeMethodAccessorImpl 对象赋值给 DelegatingMethodAccessorImpl 类的 delegate 属性。</p>
<p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000220034-1956129765.png" alt="image"></p>
<p>所以说ReflectionFactory 类的 newMethodAccessor 方法最终返回 DelegatingMethodAccessorImpl 类对象。所以我们在前面的 ma.invoke() 里，其将会进入 DelegatingMethodAccessorImpl 类的 invoke 方法中。</p>
<p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000232803-804506620.png" alt="image"></p>
<p>进入 DelegatingMethodAccessorImpl 类的 invoke 方法后，这里调用了 delegate 属性的 invoke 方法，它又有两个实现类，分别是：DelegatingMethodAccessorImpl 和 NativeMethodAccessorImpl。按照我们前面说到的，这里的 delegate 其实是一个 NativeMethodAccessorImpl 对象，所以这里会进入 NativeMethodAccessorImpl 的 invoke 方法。</p>
<p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000240115-804972243.png" alt="image"></p>
<p>而在 NativeMethodAccessorImpl 的 invoke 方法里，其会判断调用次数是否超过阀值（numInvocations）。如果超过该阀值，那么就会生成另一个MethodAccessor 对象，并将原来 DelegatingMethodAccessorImpl 对象中的 delegate 属性指向最新的 MethodAccessor 对象。</p>
<p>到这里，其实我们可以知道 MethodAccessor 对象其实就是具体去生成反射类的入口。通过查看源码上的注释，我们可以了解到 MethodAccessor 对象的一些设计信息。</p>
<blockquote>
<p>“Inflation” mechanism. Loading bytecodes to implement Method.invoke() and Constructor.newInstance() currently costs 3-4x more than an invocation via native code for the first invocation (though subsequent invocations have been benchmarked to be over 20x faster).Unfortunately this cost increases startup time for certain applications that use reflection intensively (but only once per class) to bootstrap themselves.</p>
<p>Inflation 机制。初次加载字节码实现反射，使用 Method.invoke() 和 Constructor.newInstance() 加载花费的时间是使用原生代码加载花费时间的 3 - 4 倍。这使得那些频繁使用反射的应用需要花费更长的启动时间。</p>
<p>To avoid this penalty we reuse the existing JVM entry points for the first few invocations of Methods and Constructors and then switch to the bytecode-based implementations. Package-private to be accessible to NativeMethodAccessorImpl and NativeConstructorAccessorImpl.</p>
<p>为了避免这种痛苦的加载时间，我们在第一次加载的时候重用了 JVM 的入口，之后切换到字节码实现的实现。</p>
</blockquote>
<p>就像注释里说的，实际的 MethodAccessor 实现有两个版本，一个是 Native 版本，一个是 Java 版本。</p>
<p>Native 版本一开始启动快，但是随着运行时间边长，速度变慢。Java 版本一开始加载慢，但是随着运行时间边长，速度变快。正是因为两种存在这些问题，所以第一次加载的时候我们会发现使用的是 NativeMethodAccessorImpl 的实现，而当反射调用次数超过 15 次之后，则使用 MethodAccessorGenerator 生成的 MethodAccessorImpl 对象去实现反射。</p>
<p>Method 类的 invoke 方法整个流程可以表示成如下的时序图：</p>
<p><img src="https://img2018.cnblogs.com/blog/595137/201903/595137-20190324000247330-1279629878.png" alt="image"></p>
<p>讲到这里，我们了解了 Method 类的 invoke 方法的具体实现方式。知道了原来 invoke 方法内部有两种实现方式，一种是 native 原生的实现方式，一种是 Java 实现方式，这两种各有千秋。而为了最大化性能优势，JDK 源码使用了代理的设计模式去实现最大化性能。</p>
<p>参考文章：</p>
<p><a href="https://blog.csdn.net/sinat_38259539/article/details/71799078" target="_blank" rel="noopener">Java基础之—反射（非常重要）</a><br><a href="http://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html" target="_blank" rel="noopener">大白话说Java反射：入门、使用、原理</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.polaris.com/2020/01/06/Java-Reflect/" data-id="ck52lgsqr000famso4eiirm5y"
         class="article-share-link">分享</a>
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java-Reflect-反射/">Java Reflect 反射</a></li></ul>

    </footer>

  </div>

  
    
  <nav class="article-nav">
    
    
      <a href="/2020/01/05/gitSummary/" class="article-nav-link">
        <strong class="article-nav-caption">后一篇</strong>
        <div class="article-nav-title">Git 学习总结</div>
      </a>
    
  </nav>


  

  
    
  <div class="gitalk" id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '34894f603fd35f8f0e4b',
      clientSecret: '9ab0cb4299775c6c6c3e9cdd6cae64cc0d8a2bbf',
      repo: 'polaris.github.io',
      owner: 'Polaris-Java',
      admin: ['Polaris-Java'],
      // id: location.pathname,      // Ensure uniqueness and length less than 50
      id: md5(location.pathname),
      distractionFreeMode: false,  // Facebook-like distraction free mode
      pagerDirection: 'last'
    })

  gitalk.render('gitalk-container')
  </script>

  

</article>



</section>
  <footer class="footer">
  <div class="outer">
    <div class="float-right">
      <ul class="list-inline">
  
    <li><i class="fe fe-smile-alt"></i> <span id="busuanzi_value_site_uv"></span></li>
  
</ul>
    </div>
    <ul class="list-inline">
      <li>&copy; 2020 北极星</li>
      <li>Theme  <a href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
      <li>
		<a href="http://www.beian.miit.gov.cn/"  style="color:#127ea9" target="_blank">陇ICP备19003991号-1</a>
      </li>
      <li>
				 	<div style="width:250px;margin:0 auto;">
		 		<a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=62012102000033" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="https://upload-images.jianshu.io/upload_images/11387217-1c6b62209158bb76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="float:left;padding-top: 4px;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px;padding-top: 5px; color:#127ea9;">甘公网安备 62012102000033号</p></a>
		 	</div>
		 

	 </li>
    </ul>
  </div>
</footer>

</main>

<aside class="sidebar sidebar-specter">
  
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
    <div class="logo">
      <a href="/"><img src="/favicon.ico" alt="北极星"></a>
    </div>
  
  <ul class="nav nav-main">
    
      <li class="nav-item">
        <a class="nav-item-link" href="/">主页</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/archives">归档</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/gallery">相册</a>
      </li>
    
      <li class="nav-item">
        <a class="nav-item-link" href="/about">关于</a>
      </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
        <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
          <i class="fe fe-feed"></i>
        </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>

  <script src="/fancybox/jquery.fancybox.min.js"></script>



  <script src="/js/tocbot.min.js"></script>
  <script>
    // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
    tocbot.init({
      tocSelector: '.tocbot',
      contentSelector: '.article-entry',
      headingSelector: 'h1, h2, h3, h4, h5, h6',
      hasInnerContainers: true,
      scrollSmooth: true,
      positionFixedSelector: '.tocbot',
      positionFixedClass: 'is-position-fixed',
      fixedSidebarOffset: 'auto',
    });
  </script>


<script src="/js/ocean.js"></script>

</body>
</html>